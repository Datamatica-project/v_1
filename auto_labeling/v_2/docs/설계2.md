# FastAPI Auto-Labeling V1 시스템 설계 문서 (3모델 앙상블 방식)

> **중요**: 이 설계는 현재 v_1의 Student-Teacher Loop 방식을 **설계.md의 3모델 앙상블 방식**으로 전환하는 것을 목표로 합니다.

## 목차
1. [시스템 개요](#1-시스템-개요)
2. [전체 아키텍처](#2-전체-아키텍처)
3. [프로젝트 구조](#3-프로젝트-구조)
4. [핵심 API 설계](#4-핵심-api-설계)
5. [데이터 흐름](#5-데이터-흐름)
6. [앙상블 처리 로직](#6-앙상블-처리-로직)
7. [이벤트 및 상태 관리](#7-이벤트-및-상태-관리)
8. [기존 v_1과의 차이점](#8-기존-v_1과의-차이점)
9. [마이그레이션 계획](#9-마이그레이션-계획)

---

## 1. 시스템 개요

### 1.1 시스템 목적
교통사고 현장 데이터를 자동으로 라벨링하는 AI 기반 시스템으로, **3개의 AI 모델을 사용한 앙상블**을 통해 높은 신뢰도의 라벨링을 제공합니다.

### 1.2 핵심 개념

#### 용어 정의
- **Loop**: 전체 자동 라벨링 작업 단위 (loop_id로 식별)
  - 하나의 Loop는 여러 Round를 포함
  - Loop ID와 Run ID는 1:1 매핑 (loop_abc123 ↔ run_20250106_120000_xyz789)
- **Round**: 반복 학습 및 추론 단위 (0, 1, 2, ...)
  - **Round 0**: 사전 학습된 모델로 전체 Unlabeled 이미지 첫 추론
  - **Round 1+**: 이전 Round의 FAIL 데이터로 모델 재학습 → **전체 Unlabeled 재추론**
  - 각 Round는 독립적인 결과 디렉토리 보유 (`run_0`, `run_1`, ...)
  - **현재**: Round 0, 1, 2까지 고정 (총 3회)
  - **향후**: 동적 Round 수 조정 가능 (종료 조건 기반)

#### 모델 및 앙상블
- **3개 독립 모델**: YOLO, Model2 (Custom COCO), Model3 (Custom COCO)
  - 각 모델은 독립적으로 사전 학습 완료 (GT 데이터 사용)
  - **Round 1+**: 이전 Round의 FAIL 데이터로 각 모델 재학습
- **병렬 추론**: 3개 모델이 동시에 이미지 추론
  - GPU 충분 시: 3개 모델 동시 로드 (병렬)
  - GPU 부족 시: 1개씩 순차 추론 (sequential)
- **앙상블 분류**: 모델들의 PASS/FAIL 결과를 조합하여 최종 판정
  - PASS 판정: bbox가 1개 이상 검출 (conf >= conf_threshold)
  - **PASS_THREE**: 3개 모두 PASS (최고 신뢰도, ~65%)
  - **PASS_TWO**: 2개 PASS, 1개 FAIL (높은 신뢰도, ~20%)
  - **FAIL**: 1개 PASS, 2개 FAIL (낮은 신뢰도, ~10%)
  - **MISS**: 3개 모두 FAIL (검출 실패, ~5%)

#### Round 반복 전략
- **Round 0**:
  - 사전 학습된 3개 모델로 전체 Unlabeled 이미지 병렬 추론
  - 앙상블 분류 → PASS_THREE/TWO/FAIL/MISS

- **Round 1+**:
  - **재학습 단계**: 이전 Round의 FAIL 데이터로 각 모델 재학습
    - YOLO: FAIL 이미지 + GT Anchor → Fine-tuning
    - Model2: FAIL 이미지 + GT Anchor → Fine-tuning
    - Model3: FAIL 이미지 + GT Anchor → Fine-tuning
  - **재추론 단계**: 재학습된 모델로 **전체 Unlabeled** 이미지 재추론
    - FAIL만 재추론하는 것이 아니라, 모든 이미지를 처음부터 다시 추론
    - 이전 Round에서 PASS였던 이미지도 재학습된 모델로 재평가
  - 앙상블 분류 → PASS_THREE/TWO/FAIL/MISS

- **종료 조건**:
  - **현재**: Round 2 완료 시 종료 (고정: 0, 1, 2)
  - **향후 확장 가능**: 동적 종료 조건
    - max_rounds 도달
    - FAIL + MISS 비율 < threshold
    - 개선 없음 patience 도달
    - FAIL + MISS 0개

### 1.3 기술 스택
- **API Server**: FastAPI (Python 3.9+)
- **Worker Server**: FastAPI (별도 프로세스, Loop 실행)
- **비동기 처리**: Python Threading
- **상태 관리**: 파일 시스템 기반 (JSON 이벤트 로그)
- **통신**: REST API + 폴링 (Redis/WebSocket 미사용)
- **AI Models**:
  - Model 1: YOLO (ultralytics)
  - Model 2: Custom COCO 모델
  - Model 3: Custom COCO 모델
- **스토리지**: MinIO (선택적), 로컬 파일 시스템

### 1.4 핵심 설계 원칙
- ✅ **Redis, WebSocket, SSE 사용 안 함**: 파일 기반 이벤트 로그
- ✅ **폴링 최적화**: Spring Boot가 2~3초마다 이벤트 조회
- ✅ **모델별 독립 관리**: 각 모델의 GT/Unlabeled 데이터 별도 관리
- ✅ **외부 의존성 최소화**: 파일 시스템 기반 상태 관리

---

## 2. 전체 아키텍처

### 2.1 시스템 구성도

```
┌────────────────────────────────────────────────────────────────┐
│                    Spring Boot (Backend)                       │
│  - React ↔ FastAPI API 중계                                   │
│  - 폴링 관리 (/api/v1/loop/status, /api/v1/events/latest)    │
│  - 인증/인가                                                   │
└─────────────────────┬──────────────────────────────────────────┘
                      │ HTTP REST API
                      ▼
┌────────────────────────────────────────────────────────────────┐
│              FastAPI API Server (v1-api:8010)                  │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ API Endpoints (Proxy + Registry)                         │ │
│  │  - /api/v1/gt/ingests/*        : GT 업로드/등록         │ │
│  │  - /api/v1/unlabeled/ingests/* : Unlabeled 업로드       │ │
│  │  - /api/v1/loop/run            : Loop 시작 (Worker 호출)│ │
│  │  - /api/v1/loop/status/{jobId} : Loop 상태 조회         │ │
│  │  - /api/v1/events/*            : 이벤트 수신/조회       │ │
│  │  - /api/v1/results/*           : 결과 프리뷰 생성/조회  │ │
│  │  - /api/v1/export/*            : Round0/Final 결과 Export│ │
│  └──────────────────────────────────────────────────────────┘ │
└─────────────────────┬──────────────────────────────────────────┘
                      │ HTTP (Worker 프록시)
                      ▼
┌────────────────────────────────────────────────────────────────┐
│            FastAPI Worker Server (v1-worker:8011)              │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ Ensemble Loop 실행 Worker (별도 Thread)                 │ │
│  │  1. 3개 모델 병렬 추론 (YOLO, Model2, Model3)           │ │
│  │  2. 앙상블 분류 (PASS_THREE/TWO/FAIL/MISS)              │ │
│  │  3. Bbox 병합 (NMS + 평균화)                            │ │
│  │  4. Round 반복 (FAIL+MISS 재추론, 종료 조건까지)        │ │
│  │  5. 최종 결과 병합 (모든 Round의 PASS 통합)             │ │
│  │  6. 이벤트 콜백 (API Server로 진행 상황 전송)           │ │
│  └──────────────────────────────────────────────────────────┘ │
│                                                                │
│  ┌──────────────────────────────────────────────────────────┐ │
│  │ AI Model Layer                                           │ │
│  │  - Model 1: YOLO (ultralytics)                           │ │
│  │  - Model 2: Custom COCO Model                            │ │
│  │  - Model 3: Custom COCO Model                            │ │
│  └──────────────────────────────────────────────────────────┘ │
└─────────────────────┬──────────────────────────────────────────┘
                      │
                      ▼
┌────────────────────────────────────────────────────────────────┐
│                  File Storage (Local/NAS)                      │
│  auto_labeling/v_1/data/                                       │
│  ├── gt_data/               (모델별 GT 데이터)                │
│  │   ├── yolo/                                                │
│  │   │   ├── GT_202601/                                       │
│  │   │   │   ├── images/                                      │
│  │   │   │   ├── labels/                                      │
│  │   │   │   └── data.yaml                                    │
│  │   │   └── GT.file → GT_202601  (현재 활성 GT, symlink)    │
│  │   ├── model2/ (동일 구조)                                  │
│  │   └── model3/ (동일 구조)                                  │
│  ├── unlabeled/             (모델별 Unlabeled 이미지)         │
│  │   ├── yolo/images/                                         │
│  │   ├── model2/images/                                       │
│  │   └── model3/images/                                       │
│  ├── results/               (Loop 결과)                       │
│  │   └── loop_{loop_id}/                                      │
│  │       ├── run_0/         (Round 0 결과)                    │
│  │       │   ├── PASS_THREE/ (images/, labels/)               │
│  │       │   ├── PASS_TWO/   (images/, labels/)               │
│  │       │   ├── FAIL/       (images/, labels/)               │
│  │       │   └── MISS/       (images/)                        │
│  │       ├── run_1/         (Round 1 결과)                    │
│  │       ├── run_N/         (Round N 결과)                    │
│  │       └── final/         (최종 병합 결과)                  │
│  │           ├── PASS/      (모든 Round PASS 통합)           │
│  │           ├── FAIL/      (최종 Round FAIL)                │
│  │           └── MISS/      (최종 Round MISS)                │
│  ├── exports/               (Export 결과 캐시)                │
│  │   └── {loop_id}/                                           │
│  │       ├── run_0.zip      (Round 0 ZIP)                     │
│  │       ├── run_1.zip      (Round 1 ZIP)                     │
│  │       └── final.zip      (최종 결과 ZIP)                   │
│  ├── raw_ingest/            (업로드 임시 저장)                │
│  └── logs/                                                     │
│      ├── events/{loop_id}/  (이벤트 로그 JSON)                │
│      └── previews/{loop_id}/(프리뷰 이미지)                   │
└────────────────────────────────────────────────────────────────┘
```

### 2.2 폴링 흐름

```
┌─────────────┐
│ Spring Boot │
└──────┬──────┘
       │
       │ 폴링 루프 (2~3초)
       │
       │ GET /api/v1/events/latest?runId=xxx&eventType=LOOP_PROGRESS
       ▼
┌─────────────┐
│  API Server │ → logs/events/<runId>/*.json 파일 읽기
└──────┬──────┘
       │
       │ 최신 이벤트 반환
       ▼
┌─────────────┐
│ Spring Boot │ → React UI 업데이트
└─────────────┘
```

---

## 3. 프로젝트 구조

### 3.1 디렉토리 구조

```
auto_labeling/v_1/
├── api/
│   ├── server.py                    # API Server 진입점 (8010)
│   ├── routers/
│   │   ├── ingest.py                # GT/Unlabeled 업로드/등록
│   │   ├── loop.py                  # Loop 시작/상태 조회 (Worker 프록시)
│   │   ├── events.py                # 이벤트 수신/조회
│   │   ├── results.py               # 결과 프리뷰 생성/조회
│   │   ├── export.py                # Export Final
│   │   ├── export_round0.py         # Export Round0
│   │   └── logs.py                  # 로그 조회
│   └── dto/
│       ├── loop.py                  # Loop 요청/응답 DTO
│       ├── event.py                 # Event DTO
│       └── ...
│
├── worker/
│   ├── server.py                    # Worker Server 진입점 (8011)
│   └── routers/
│       ├── loop_worker.py           # Loop 실행 Worker
│       ├── events_worker.py         # 이벤트 콜백 클라이언트
│       └── export_round0_worker.py  # Round0 Export Worker
│
├── src/
│   ├── loop_controller.py           # Loop 핵심 로직 (run_loop, run_one_round)
│   ├── gt_register.py               # GT 등록 (검증 + 복사/심볼릭 링크)
│   ├── pass_fail_filter.py          # Student 모델로 PASS/FAIL 분류
│   ├── teacher_runner.py            # Teacher 모델 추론
│   ├── teacher_runner_DINO.py       # Grounding DINO Teacher
│   ├── yolo_mini_trainer.py         # Student 모델 재학습 (Micro Fine-tuning)
│   └── export_pass_fail_final.py    # 최종 결과 Export
│
├── scripts/
│   ├── logger.py                    # 로그 유틸리티
│   └── ...
│
├── storage/
│   └── minio_client.py              # MinIO 클라이언트 (선택적)
│
├── configs/
│   ├── classes.yaml                 # 클래스 정의
│   ├── v1_loop_real.yaml            # Loop 설정 (epochs, lr, 등)
│   └── teacher_model.yaml           # Teacher 모델 설정
│
├── data/                            # 데이터 저장소 (위 구조 참조)
│
└── models/
    └── teacher/
        └── GroundingDINO_SwinB.cfg.py
```

---

## 4. 핵심 API 설계

### 4.1 GT 업로드 및 등록

#### 1) GT ZIP 업로드

```http
POST /api/v1/gt/ingests/upload
Content-Type: multipart/form-data

Parameters:
- file: ZIP 파일 (images/, labels/ 포함)
- source_name: GT 제공처 (선택)
- dataset_name: 데이터셋 이름 (선택)

Response: 200 OK
{
  "ingest_id": "gt_20250106_120000_abc123",
  "status": "UPLOADED",
  "extracted": "/workspace/.../raw_ingest/gt_xxx/extracted",
  "next": "/api/v1/gt/ingests/{ingestId}/register"
}
```

#### 2) GT 등록 (표준화 + 현재 GT 갱신)

```http
POST /api/v1/gt/ingests/{ingest_id}/register
Query Parameters:
- copy_mode: symlink | copy (기본: symlink)
- strict: true | false (기본: false)

Response: 200 OK
{
  "ingest_id": "gt_20250106_120000_abc123",
  "status": "DONE",
  "registered": ".../GT_versions/GT_gt_xxx",
  "current_GT": ".../data/GT",
  "summary": {
    "ok": 1500,
    "skip": 0,
    "error": 0
  }
}
```

**처리 과정:**
1. `extracted/images`, `extracted/labels` 검증
2. `GT_versions/GT_{ingestId}`로 복사 또는 심볼릭 링크
3. 라벨 형식 검증 (YOLO 형식: `class cx cy w h`)
4. `data/GT` 심볼릭 링크를 최신 버전으로 갱신
5. `data.yaml` 생성

**파일:** `auto_labeling/v_1/api/routers/ingest.py`, `auto_labeling/v_1/src/gt_register.py`

---

### 4.2 Unlabeled 업로드

```http
POST /api/v1/unlabeled/ingests/upload
Content-Type: multipart/form-data

Parameters:
- file: ZIP 파일 (이미지만, 구조 자유)
- dataset_name: 데이터셋 이름 (선택)

Response: 200 OK
{
  "ingest_id": "unlabeled_xxx",
  "status": "DONE",
  "added_images": 500,
  "unlabeled_dir": ".../data/unlabeled/images"
}
```

**처리:**
- ZIP 내 모든 이미지 파일(.jpg, .jpeg, .png, .bmp, .webp)을 `data/unlabeled/images`로 복사

---

### 4.3 Loop 실행

#### 1) Loop 시작

```http
POST /api/v1/loop/start
Content-Type: application/json

Request Body:
{
  "models": ["yolo", "model2", "model3"],
  "configOverride": {
    "max_rounds": 4,
    "conf_threshold": 0.5,
    "fail_threshold": 0.01,
    "min_fail_count": 100,
    "patience": 2,
    "iou_threshold": 0.5
  }
}

Response: 200 OK
{
  "loopId": "loop_abc123",
  "runId": "run_20250106_120000_xyz789",
  "status": "STARTED",
  "message": "Ensemble loop started"
}
```

**처리 과정:**
1. API Server가 Worker Server로 프록시 (`http://v1-worker:8011/api/v1/loop/start`)
2. Worker가 별도 Thread에서 Ensemble Loop 실행 시작
3. 즉시 `loopId`, `runId` 반환
4. Worker는 Loop 진행 중 이벤트를 API Server로 콜백 (`POST /api/v1/events`)

**파일:**
- API: `auto_labeling/v_1/api/routers/loop.py`
- Worker: `auto_labeling/v_1/worker/routers/loop_worker.py`
- Core: `auto_labeling/v_1/src/ensemble_service.py` (신규)

---

#### 2) Loop 상태 조회

```http
GET /api/v1/loop/status/{loop_id}

Response: 200 OK
{
  "loopId": "loop_abc123",
  "runId": "run_20250106_120000_xyz789",
  "status": "RUNNING",
  "stats": {
    "currentRound": 1,
    "totalRounds": 4,
    "roundHistory": [
      {
        "round": 0,
        "total": 1000,
        "passThree": 650,
        "passTwo": 200,
        "fail": 100,
        "miss": 50,
        "failMissRatio": 0.15
      }
    ],
    "latestFailMissRatio": 0.15,
    "results": {
      "note": "Results are built by /api/v1/results/* endpoints",
      "suggested": {
        "roundPreview": "/api/v1/results/round/{round_number}/preview?loopId=xxx",
        "finalPreview": "/api/v1/results/final/preview?loopId=xxx"
      }
    }
  }
}
```

**처리:**
1. Worker로부터 현재 Loop 상태 조회 (프록시)
2. Round별 히스토리 반환 (PASS_THREE/TWO/FAIL/MISS 통계)
3. 결과 생성은 하지 않음 (GET은 멱등성 유지, 결과는 `/api/v1/results/*`에서 POST로 생성)

---

### 4.4 이벤트 API

#### 1) 이벤트 수신 (콜백)

```http
POST /api/v1/events
Content-Type: application/json

Request Body:
{
  "eventType": "LOOP_PROGRESS",
  "runId": "run_xxx",
  "data": {
    "currentRound": 1,
    "totalRounds": 3,
    "failRatio": 0.25,
    "message": "Round 1 completed"
  }
}

Response: 200 OK
{
  "resultCode": "SUCCESS",
  "message": "Event received"
}
```

**처리:**
- `logs/events/<runId>/<timestamp>_<eventType>.json`에 저장
- Worker가 Loop 진행 중 주요 이벤트 발생 시 호출

**이벤트 타입:**
- `LOOP_STARTED`: Loop 시작
- `LOOP_PROGRESS`: 라운드 진행 상황
- `LOOP_COMPLETED`: Loop 완료
- `LOOP_FAILED`: Loop 실패
- `ROUND_STARTED`: 라운드 시작
- `ROUND_COMPLETED`: 라운드 완료

---

#### 2) 최신 이벤트 조회 (폴링용)

```http
GET /api/v1/events/latest
Query Parameters:
- runId: run_xxx (필수)
- eventType: LOOP_PROGRESS (선택)

Response: 200 OK
{
  "resultCode": "SUCCESS",
  "data": {
    "receivedAt": "2025-01-06T12:30:00Z",
    "event": {
      "eventType": "LOOP_PROGRESS",
      "runId": "run_xxx",
      "data": {
        "currentRound": 1,
        "totalRounds": 3,
        "failRatio": 0.25
      }
    },
    "_fileName": "20250106_123000_123456_LOOP_PROGRESS.json"
  }
}
```

**처리:**
- `logs/events/<runId>/` 아래 파일들을 mtime 내림차순 정렬
- eventType 필터링 (선택)
- 최신 1개 반환

**Spring Boot 폴링 예시:**
```java
// 2~3초마다 호출
@Scheduled(fixedDelay = 2000)
public void pollLoopProgress() {
    String url = apiBaseUrl + "/api/v1/events/latest?runId=" + runId
                 + "&eventType=LOOP_PROGRESS";
    ResponseEntity<ApiEnvelope> response = restTemplate.getForEntity(url, ApiEnvelope.class);
    // UI 업데이트
}
```

---

### 4.5 결과 조회

#### 1) Round별 프리뷰 생성 (멱등)

```http
POST /api/v1/results/round/{round_number}/buildPreviewSet
Content-Type: application/json

Request Body:
{
  "loopId": "loop_xxx",
  "categories": ["PASS_THREE", "PASS_TWO", "FAIL", "MISS"],
  "samplesPerCategory": 5
}

Response: 200 OK
{
  "resultCode": "SUCCESS",
  "message": "Preview set built",
  "data": {
    "loopId": "loop_xxx",
    "round": 0,
    "previewCount": 20,
    "previewDir": "logs/previews/loop_xxx/run_0"
  }
}
```

**처리:**
- `data/results/loop_{loop_id}/run_{round}/` 각 카테고리에서 샘플 선택
- 바운딩 박스 그려서 `logs/previews/{loop_id}/run_{round}/`에 저장
- 멱등: 이미 존재하면 재생성하지 않음

---

#### 2) Round별 프리뷰 조회

```http
GET /api/v1/results/round/{round_number}/preview
Query Parameters:
- loopId: loop_xxx (필수)

Response: 200 OK
{
  "resultCode": "SUCCESS",
  "data": {
    "loopId": "loop_xxx",
    "round": 0,
    "images": [
      {
        "category": "PASS_THREE",
        "fileName": "img_001_preview.jpg",
        "url": "/api/v1/results/round/0/image?loopId=xxx&fileName=img_001_preview.jpg"
      },
      ...
    ]
  }
}
```

---

### 4.6 Export API

#### 1) Round별 Export

```http
GET /api/v1/export/{loop_id}/run/{run_number}

Response: 200 OK (ZIP 파일)
Content-Type: application/zip
Content-Disposition: attachment; filename="loop_{loop_id}_run_{run_number}.zip"

ZIP 내용:
├── PASS_THREE/
│   ├── images/
│   └── labels/
├── PASS_TWO/
│   ├── images/
│   └── labels/
├── FAIL/
│   ├── images/
│   └── labels/
└── MISS/
    └── images/
```

**처리:**
- `data/results/loop_{loop_id}/run_{run_number}/` 디렉토리를 ZIP으로 압축
- `exports/{loop_id}/run_{run_number}.zip` 에 캐시 (재생성 방지)

---

#### 2) Final Export (전체 통합)

```http
GET /api/v1/export/{loop_id}/final

Response: 200 OK (ZIP 파일)
Content-Type: application/zip
Content-Disposition: attachment; filename="loop_{loop_id}_final.zip"

ZIP 내용:
├── PASS/              (모든 Round의 PASS_THREE + PASS_TWO 통합)
│   ├── images/
│   └── labels/
├── FAIL/              (최종 Round의 FAIL)
│   ├── images/
│   └── labels/
└── MISS/              (최종 Round의 MISS)
    └── images/
```

**처리:**
- 모든 Round의 `PASS_THREE/`, `PASS_TWO/`를 PASS로 병합
- 최종 Round의 `FAIL/`을 FAIL로
- 최종 Round의 `MISS/`를 MISS로 복사
- `exports/{loop_id}/final.zip` 에 캐시

---

## 5. 데이터 흐름 (3모델 앙상블 + Round 반복)

### 5.1 전체 데이터 흐름

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 준비 단계                                                │
├─────────────────────────────────────────────────────────────┤
│ 모델별 GT 업로드/등록:                                      │
│ - POST /api/v1/yolo/gt/download → GT 등록                  │
│ - POST /api/v1/model2/gt/download → GT 등록                │
│ - POST /api/v1/model3/gt/download → GT 등록                │
│                                                             │
│ 모델별 Unlabeled 업로드:                                    │
│ - POST /api/v1/yolo/unlabel/upload → data/unlabeled/yolo   │
│ - POST /api/v1/model2/unlabel/upload → data/unlabeled/model2│
│ - POST /api/v1/model3/unlabel/upload → data/unlabeled/model3│
│                                                             │
│ 각 모델 독립 학습 (GT 데이터로):                            │
│ - YOLO: yolo_best.pt                                        │
│ - Model2: model2_best.pt (COCO format)                      │
│ - Model3: model3_best.pt (COCO format)                      │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│ 2. Loop 시작 (POST /api/v1/loop/start)                     │
├─────────────────────────────────────────────────────────────┤
│ Request Body:                                               │
│ {                                                           │
│   "models": ["yolo", "model2", "model3"],                   │
│   "configOverride": {                                       │
│     "max_rounds": 4,                                        │
│     "conf_threshold": 0.5,                                  │
│     "fail_threshold": 0.01                                  │
│   }                                                         │
│ }                                                           │
│                                                             │
│ Response:                                                   │
│ {                                                           │
│   "loopId": "loop_abc123",                                  │
│   "runId": "run_xyz789",                                    │
│   "status": "STARTED"                                       │
│ }                                                           │
│                                                             │
│ Worker Thread 시작 → 즉시 반환                              │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│ 3. Round 0 (Worker Thread) - 첫 추론                        │
├─────────────────────────────────────────────────────────────┤
│ Input: 모든 Unlabeled 이미지 (1000장 예시)                  │
│                                                             │
│ Step 1) 3모델 병렬 추론                                     │
│   - YOLO 추론:   800 PASS, 200 FAIL                        │
│   - Model2 추론: 750 PASS, 250 FAIL                        │
│   - Model3 추론: 780 PASS, 220 FAIL                        │
│                                                             │
│ Step 2) 앙상블 분류 (이미지별)                              │
│   이미지 img_001.jpg:                                       │
│     YOLO: PASS, Model2: PASS, Model3: PASS → PASS_THREE    │
│   이미지 img_002.jpg:                                       │
│     YOLO: PASS, Model2: PASS, Model3: FAIL → PASS_TWO      │
│   이미지 img_003.jpg:                                       │
│     YOLO: PASS, Model2: FAIL, Model3: FAIL → FAIL          │
│   이미지 img_004.jpg:                                       │
│     YOLO: FAIL, Model2: FAIL, Model3: FAIL → MISS          │
│                                                             │
│ Step 3) 결과 저장                                           │
│   - PASS_THREE: 650장 → data/results/loop_abc/run_0/PASS_THREE/│
│   - PASS_TWO:   200장 → data/results/loop_abc/run_0/PASS_TWO/  │
│   - FAIL:       100장 → data/results/loop_abc/run_0/FAIL/      │
│   - MISS:        50장 → data/results/loop_abc/run_0/MISS/      │
│                                                             │
│ Step 4) 라벨 병합 (앙상블 bbox)                             │
│   - PASS_THREE/TWO의 경우: 3개 모델 bbox 평균화            │
│   - YOLO format으로 변환하여 labels/ 저장                  │
│                                                             │
│ 이벤트 콜백:                                                │
│   POST /api/v1/events {                                     │
│     "eventType": "ROUND_COMPLETED",                         │
│     "runId": "run_xyz789",                                  │
│     "data": {                                               │
│       "round": 0,                                           │
│       "passThree": 650,                                     │
│       "passTwo": 200,                                       │
│       "fail": 100,                                          │
│       "miss": 50,                                           │
│       "failMissRatio": 0.15                                 │
│     }                                                       │
│   }                                                         │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│ 4. Round 1 (Worker Thread) - 재학습 + 전체 재추론          │
├─────────────────────────────────────────────────────────────┤
│ Step 1) 재학습 단계                                         │
│   - Round 0의 FAIL(100) 이미지로 각 모델 재학습            │
│   - YOLO: FAIL 100장 + GT Anchor → Fine-tuning             │
│   - Model2: FAIL 100장 + GT Anchor → Fine-tuning           │
│   - Model3: FAIL 100장 + GT Anchor → Fine-tuning           │
│                                                             │
│ Step 2) 전체 Unlabeled 재추론 (1000장 전체)                 │
│   - YOLO 재추론:   850 PASS, 150 FAIL                      │
│   - Model2 재추론: 800 PASS, 200 FAIL                      │
│   - Model3 재추론: 820 PASS, 180 FAIL                      │
│                                                             │
│ Step 3) 앙상블 분류 (전체 1000장)                           │
│   - PASS_THREE: 700장 (개선: +50)                          │
│   - PASS_TWO:   220장 (개선: +20)                          │
│   - FAIL:        60장 (감소: -40)                          │
│   - MISS:        20장 (감소: -30)                          │
│                                                             │
│ Step 4) 결과 저장                                           │
│   data/results/loop_abc/run_1/PASS_THREE/                   │
│   data/results/loop_abc/run_1/PASS_TWO/                     │
│   data/results/loop_abc/run_1/FAIL/                         │
│   data/results/loop_abc/run_1/MISS/                         │
│                                                             │
│ 이벤트 콜백: ROUND_COMPLETED (failMissRatio: 0.08)         │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│ 5. Round 2 - 재학습 + 전체 재추론                           │
├─────────────────────────────────────────────────────────────┤
│ Step 1) 재학습: Round 1의 FAIL(60)로 각 모델 재학습        │
│ Step 2) 전체 Unlabeled 재추론 (1000장 전체)                 │
│ Step 3) 앙상블 → PASS_THREE(750), PASS_TWO(210),           │
│                  FAIL(30), MISS(10)                         │
│                                                             │
│ 현재: Round 2 완료 시 종료 (고정: 0, 1, 2)                  │
│                                                             │
│ 향후 확장 가능 종료 조건:                                   │
│ ✅ max_rounds 도달                                          │
│ ✅ FAIL + MISS 비율 < threshold                            │
│ ✅ 개선 없음 patience 도달                                  │
└─────────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────┐
│ 6. Loop 완료                                                │
├─────────────────────────────────────────────────────────────┤
│ 이벤트 콜백: LOOP_COMPLETED                                 │
│                                                             │
│ 최종 결과:                                                  │
│ - Round별 Export:                                           │
│   GET /api/v1/export/{loop_id}/run/0  (Round 0 결과)       │
│   GET /api/v1/export/{loop_id}/run/1  (Round 1 결과)       │
│   GET /api/v1/export/{loop_id}/run/2  (Round 2 결과)       │
│                                                             │
│ - Final Export:                                             │
│   GET /api/v1/export/{loop_id}/final                        │
│   → PASS: 모든 Round의 PASS_THREE + PASS_TWO 병합         │
│   → FAIL: 최종 Round의 FAIL                                │
│   → MISS: 최종 Round의 MISS                                │
└─────────────────────────────────────────────────────────────┘
```

---

### 5.2 Round별 디렉토리 구조 (3모델 앙상블)

#### 데이터 저장 구조

```
data/
├── gt_data/                      # 모델별 GT 데이터
│   ├── yolo/
│   │   ├── GT_202601/
│   │   │   ├── images/
│   │   │   ├── labels/
│   │   │   └── data.yaml
│   │   └── GT.file → GT_202601  # 현재 활성 GT (심볼릭 링크)
│   ├── model2/
│   │   └── (동일 구조)
│   └── model3/
│       └── (동일 구조)
│
├── unlabeled/                    # 모델별 Unlabeled 이미지
│   ├── yolo/
│   │   └── images/
│   ├── model2/
│   │   └── images/
│   └── model3/
│       └── images/
│
└── results/                      # Loop 결과
    └── loop_{loop_id}/           # Loop 단위
        ├── run_0/                # Round 0 결과
        │   ├── PASS_THREE/
        │   │   ├── images/
        │   │   └── labels/       # 3모델 bbox 평균화
        │   ├── PASS_TWO/
        │   │   ├── images/
        │   │   └── labels/
        │   ├── FAIL/
        │   │   ├── images/
        │   │   └── labels/
        │   └── MISS/
        │       └── images/       # 라벨 없음
        │
        ├── run_1/                # Round 1 결과 (FAIL+MISS 재추론)
        │   ├── PASS_THREE/
        │   ├── PASS_TWO/
        │   ├── FAIL/
        │   └── MISS/
        │
        ├── run_2/                # Round 2 결과
        │   └── ...
        │
        └── final/                # 최종 병합 결과 (export용)
            ├── PASS/             # 모든 Round의 PASS_THREE + PASS_TWO
            │   ├── images/
            │   └── labels/
            ├── FAIL/             # 최종 Round의 FAIL
            │   ├── images/
            │   └── labels/
            └── MISS/             # 최종 Round의 MISS
                └── images/
```

#### Round별 특징

| Round | 재학습 | Input (추론) | Output | 설명 |
|-------|-------|------------|--------|------|
| **Round 0** | - | 모든 Unlabeled (1000장) | PASS_THREE(650), PASS_TWO(200), FAIL(100), MISS(50) | 사전 학습 모델로 첫 추론 |
| **Round 1** | FAIL 100장 | 모든 Unlabeled (1000장) | PASS_THREE(700), PASS_TWO(220), FAIL(60), MISS(20) | FAIL로 재학습 후 전체 재추론 |
| **Round 2** | FAIL 60장 | 모든 Unlabeled (1000장) | PASS_THREE(750), PASS_TWO(210), FAIL(30), MISS(10) | FAIL로 재학습 후 전체 재추론 |

**핵심 포인트:**
- 모든 Round에서 **전체 Unlabeled** 이미지를 추론 (부분 추론 아님)
- Round 1+는 이전 FAIL 데이터로 재학습 후 전체 재추론
- 각 Round마다 모델이 개선되어 PASS 비율 증가

#### Round 진행 예시 (1000장 시작)

```
Round 0: 사전 학습 모델
  → 1000장 추론 → P3(650) + P2(200) + F(100) + M(50)
  → FAIL+MISS = 150장 (15%)

Round 1: FAIL 100장으로 재학습
  → 1000장 재추론 → P3(700) + P2(220) + F(60) + M(20)
  → FAIL+MISS = 80장 (8% → 47% 개선)

Round 2: FAIL 60장으로 재학습
  → 1000장 재추론 → P3(750) + P2(210) + F(30) + M(10)
  → FAIL+MISS = 40장 (4% → 50% 개선)
  → 현재 설정: Round 2에서 종료

최종 결과 (Round 2 기준):
- PASS: 750 + 210 = 960장 (96%)
- FAIL: 30장 (3%)
- MISS: 10장 (1%)
```

---

## 6. 앙상블 처리 로직 (3모델 병렬 + Round 반복)

### 6.1 핵심 함수

**파일:** `auto_labeling/v_1/src/ensemble_service.py` (신규)

#### 1) `run_ensemble_loop()` - 전체 Loop 실행

```python
def run_ensemble_loop(
    *,
    models: list[str],          # ["yolo", "model2", "model3"]
    unlabeled_dirs: dict[str, Path],  # {model: unlabeled_img_dir}
    config: dict,
    loop_id: str,
    run_id: str
) -> tuple[dict, list[dict]]:
    """
    3모델 앙상블 Loop 전체 실행 (Round 반복)

    Args:
        models: 사용할 모델 리스트
        unlabeled_dirs: 모델별 unlabeled 이미지 디렉토리
        config: 앙상블 설정 (max_rounds, thresholds, ...)
        loop_id: Loop 식별자
        run_id: Run 식별자

    Returns:
        (최종 통계, Round별 히스토리)
    """
    max_rounds = int(config.get("max_rounds", 4))
    fail_threshold = float(config.get("fail_threshold", 0.01))
    min_fail_count = int(config.get("min_fail_count", 100))
    patience = int(config.get("patience", 2))

    history = []
    no_improve = 0
    prev_fail_miss_ratio = 1.0

    for round_idx in range(max_rounds):
        # Round 실행
        # Round 0: 사전 학습 모델로 추론
        # Round 1+: FAIL 데이터로 재학습 후 전체 Unlabeled 재추론
        round_result = run_one_round(
            models=models,
            unlabeled_dirs=unlabeled_dirs,  # 모든 Round에서 전체 Unlabeled 사용
            config=config,
            loop_id=loop_id,
            run_id=run_id,
            round_idx=round_idx
        )

        history.append(round_result)

        # 이벤트 콜백
        send_event("ROUND_COMPLETED", run_id, round_result)

        # 종료 조건 체크
        fail_miss_ratio = round_result["failMissRatio"]
        fail_miss_count = round_result["fail"] + round_result["miss"]

        # 1) FAIL+MISS 비율 임계값 미만
        if fail_miss_ratio < fail_threshold:
            log(f"[ENSEMBLE] STOP: fail_miss_ratio {fail_miss_ratio:.4f} < {fail_threshold}")
            break

        # 2) FAIL+MISS 개수 임계값 미만
        if fail_miss_count < min_fail_count:
            log(f"[ENSEMBLE] STOP: fail_miss_count {fail_miss_count} < {min_fail_count}")
            break

        # 3) 개선 없음 (patience)
        improvement = prev_fail_miss_ratio - fail_miss_ratio
        if improvement < 0.001:  # 0.1% 미만 개선
            no_improve += 1
            if no_improve >= patience:
                log(f"[ENSEMBLE] STOP: no improvement for {patience} rounds")
                break
        else:
            no_improve = 0

        prev_fail_miss_ratio = fail_miss_ratio

        # 다음 Round 준비
        # Round 1+는 자동으로 FAIL 데이터로 재학습 후 전체 재추론

    # 최종 병합 (final/ 디렉토리)
    final_result = merge_all_rounds(history, loop_id)

    return final_result, history
```

---

#### 2) `run_one_round()` - 단일 Round 실행

```python
def run_one_round(
    *,
    models: list[str],
    unlabeled_dirs: dict[str, Path],
    config: dict,
    loop_id: str,
    run_id: str,
    round_idx: int
) -> dict:
    """
    단일 Round 실행: (재학습) → 전체 Unlabeled 추론 → 앙상블 → 저장

    Args:
        models: ["yolo", "model2", "model3"]
        unlabeled_dirs: 모델별 전체 unlabeled 이미지 디렉토리
        config: 앙상블 설정
        loop_id: Loop 식별자
        run_id: Run 식별자
        round_idx: 현재 Round 번호 (0, 1, 2, ...)

    처리 과정:
        Round 0: 사전 학습 모델로 전체 Unlabeled 추론
        Round 1+: FAIL 데이터로 재학습 → 전체 Unlabeled 재추론

    Returns:
        Round 결과 딕셔너리 (pass_three, pass_two, fail, miss, ...)
    """
    log(f"\n===== ROUND {round_idx} START =====")

    # Step 0: Round 1+ 재학습 (옵션)
    if round_idx > 0:
        # 이전 Round의 FAIL 데이터로 각 모델 재학습
        prev_fail_data = get_prev_round_fail_data(loop_id, round_idx - 1)
        for model_name in models:
            retrain_model(
                model_name=model_name,
                fail_data=prev_fail_data[model_name],
                gt_anchor=True,
                config=config
            )
        log(f"[ROUND {round_idx}] Models retrained with FAIL data")

    # Step 1: 입력 이미지 준비
    # 모든 Round에서 전체 Unlabeled 이미지 추론
    input_imgs = collect_all_unlabeled(unlabeled_dirs)

    log(f"[ROUND {round_idx}] input images: {len(input_imgs)}")

    # Step 2: 3모델 병렬 추론
    model_results = {}  # {model_name: {img_path: prediction}}

    for model_name in models:
        model_results[model_name] = run_model_inference(
            model_name=model_name,
            images=input_imgs,
            config=config
        )

    # Step 3: 앙상블 분류
    ensemble_result = ensemble_predictions(
        model_results=model_results,
        input_imgs=input_imgs
    )
    # ensemble_result = {
    #   "PASS_THREE": [(img, [bbox1, bbox2, ...]), ...],
    #   "PASS_TWO": [...],
    #   "FAIL": [...],
    #   "MISS": [img1, img2, ...]
    # }

    # Step 4: 결과 저장
    round_dir = ROOT / "data" / "results" / f"loop_{loop_id}" / f"run_{round_idx}"
    save_ensemble_results(
        ensemble_result=ensemble_result,
        round_dir=round_dir
    )

    # Step 5: 통계 집계
    stats = {
        "round": round_idx,
        "total": len(input_imgs),
        "passThree": len(ensemble_result["PASS_THREE"]),
        "passTwo": len(ensemble_result["PASS_TWO"]),
        "fail": len(ensemble_result["FAIL"]),
        "miss": len(ensemble_result["MISS"]),
        "failMissRatio": (
            len(ensemble_result["FAIL"]) + len(ensemble_result["MISS"])
        ) / max(1, len(input_imgs)),
        "fail_imgs": [img for img, _ in ensemble_result["FAIL"]],
        "miss_imgs": ensemble_result["MISS"]
    }

    log(f"[ROUND {round_idx}] P3={stats['passThree']}, P2={stats['passTwo']}, "
        f"F={stats['fail']}, M={stats['miss']}, Ratio={stats['failMissRatio']:.4f}")
    log(f"===== ROUND {round_idx} END =====\n")

    return stats
```

---

#### 3) `ensemble_predictions()` - 앙상블 로직

```python
def ensemble_predictions(
    *,
    model_results: dict[str, dict[Path, list]],
    input_imgs: list[Path],
    iou_threshold: float = 0.5
) -> dict:
    """
    3모델 예측 결과를 앙상블하여 PASS_THREE/TWO/FAIL/MISS 분류

    Args:
        model_results: {model_name: {img_path: [bbox1, bbox2, ...]}}
        input_imgs: 입력 이미지 경로 리스트
        iou_threshold: NMS IoU 임계값 (기본: 0.5)

    Returns:
        {
          "PASS_THREE": [(img, merged_bboxes), ...],
          "PASS_TWO": [...],
          "FAIL": [...],
          "MISS": [img, ...]
        }
    """
    result = {
        "PASS_THREE": [],
        "PASS_TWO": [],
        "FAIL": [],
        "MISS": []
    }

    for img in input_imgs:
        # 각 모델의 예측 수집
        preds = {}
        for model_name, model_result in model_results.items():
            preds[model_name] = model_result.get(img, [])

        # PASS 판정: bbox가 1개 이상 있으면 PASS
        pass_count = sum(1 for bboxes in preds.values() if len(bboxes) > 0)

        if pass_count == 3:
            # 3개 모두 PASS: bbox NMS + 평균화
            merged = merge_bboxes_with_nms(preds, iou_threshold)
            result["PASS_THREE"].append((img, merged))

        elif pass_count == 2:
            # 2개 PASS: PASS인 모델들의 bbox만 NMS + 평균화
            pass_preds = {k: v for k, v in preds.items() if len(v) > 0}
            merged = merge_bboxes_with_nms(pass_preds, iou_threshold)
            result["PASS_TWO"].append((img, merged))

        elif pass_count == 1:
            # 1개 PASS: FAIL 처리 (하지만 bbox는 저장)
            pass_preds = {k: v for k, v in preds.items() if len(v) > 0}
            merged = merge_bboxes_with_nms(pass_preds, iou_threshold)
            result["FAIL"].append((img, merged))

        else:
            # 0개 PASS: MISS
            result["MISS"].append(img)

    return result
```

---

#### 4) `merge_bboxes_with_nms()` - Bbox NMS + 평균화

```python
def merge_bboxes_with_nms(
    preds: dict[str, list],
    iou_threshold: float = 0.5
) -> list:
    """
    여러 모델의 bbox를 NMS + 평균화하여 단일 bbox 리스트 생성

    Args:
        preds: {model_name: [bbox1, bbox2, ...]}
               bbox = {"class": 0, "cx": 0.5, "cy": 0.5, "w": 0.3, "h": 0.3, "conf": 0.9}
        iou_threshold: IoU 임계값 (기본: 0.5)

    Returns:
        NMS + 평균화된 bbox 리스트

    처리 과정:
        1. 모든 모델의 bbox를 하나의 리스트로 통합
        2. 좌표계 통일 (COCO absolute → YOLO normalized)
        3. 클래스별로 그룹화
        4. 각 클래스 내에서 IoU 기반 NMS 적용
        5. 동일 객체로 판정된 bbox들을 평균화
    """
    # 1) 모든 bbox를 통합하고 좌표계 통일
    all_bboxes = []
    for model_name, bboxes in preds.items():
        for bbox in bboxes:
            # 좌표계 통일: COCO format이면 YOLO format으로 변환
            normalized_bbox = normalize_bbox(bbox, model_name)
            normalized_bbox["source_model"] = model_name
            all_bboxes.append(normalized_bbox)

    # 2) 클래스별로 그룹화
    class_groups = {}
    for bbox in all_bboxes:
        cls = bbox["class"]
        if cls not in class_groups:
            class_groups[cls] = []
        class_groups[cls].append(bbox)

    # 3) 클래스별 NMS + 평균화
    merged = []
    for cls, bboxes in class_groups.items():
        # NMS: IoU > threshold인 bbox들을 그룹화
        bbox_groups = apply_nms_grouping(bboxes, iou_threshold)

        # 각 그룹 내 bbox들을 평균화
        for group in bbox_groups:
            avg_cx = sum(b["cx"] for b in group) / len(group)
            avg_cy = sum(b["cy"] for b in group) / len(group)
            avg_w = sum(b["w"] for b in group) / len(group)
            avg_h = sum(b["h"] for b in group) / len(group)
            avg_conf = sum(b["conf"] for b in group) / len(group)

            merged.append({
                "class": cls,
                "cx": avg_cx,
                "cy": avg_cy,
                "w": avg_w,
                "h": avg_h,
                "conf": avg_conf,
                "source_models": [b["source_model"] for b in group]
            })

    return merged


def apply_nms_grouping(bboxes: list, iou_threshold: float) -> list[list]:
    """
    IoU 기반으로 bbox들을 그룹화 (동일 객체 판정)

    Args:
        bboxes: bbox 리스트
        iou_threshold: IoU 임계값

    Returns:
        bbox 그룹 리스트 (각 그룹은 동일 객체로 판정된 bbox들)
    """
    # 신뢰도 기준 내림차순 정렬
    sorted_bboxes = sorted(bboxes, key=lambda x: x["conf"], reverse=True)

    groups = []
    used = set()

    for i, bbox1 in enumerate(sorted_bboxes):
        if i in used:
            continue

        # 새 그룹 시작
        group = [bbox1]
        used.add(i)

        # 나머지 bbox들과 비교
        for j, bbox2 in enumerate(sorted_bboxes):
            if j in used:
                continue

            # IoU 계산
            iou = calculate_iou(bbox1, bbox2)

            if iou >= iou_threshold:
                group.append(bbox2)
                used.add(j)

        groups.append(group)

    return groups


def normalize_bbox(bbox: dict, model_name: str) -> dict:
    """
    Bbox 좌표계를 YOLO normalized format으로 통일

    Args:
        bbox: 원본 bbox
        model_name: 모델 이름 (좌표계 판별용)

    Returns:
        YOLO normalized bbox (cx, cy, w, h: 0~1)
    """
    # YOLO는 이미 normalized
    if model_name == "yolo":
        return bbox.copy()

    # COCO format (x1, y1, x2, y2) → YOLO (cx, cy, w, h)
    if "x1" in bbox:
        x1, y1, x2, y2 = bbox["x1"], bbox["y1"], bbox["x2"], bbox["y2"]
        img_w, img_h = bbox.get("img_width", 1), bbox.get("img_height", 1)

        cx = ((x1 + x2) / 2) / img_w
        cy = ((y1 + y2) / 2) / img_h
        w = (x2 - x1) / img_w
        h = (y2 - y1) / img_h

        return {
            "class": bbox["class"],
            "cx": cx,
            "cy": cy,
            "w": w,
            "h": h,
            "conf": bbox["conf"]
        }

    return bbox.copy()
```

---

### 6.2 주요 서비스 함수

#### 1) `split_pass_fail()` - PASS/FAIL 분류

**파일:** `auto_labeling/v_1/src/pass_fail_filter.py`

```python
def split_pass_fail(
    weights: Path,
    src_img_dir: Path,
    pass_img_dir: Path,
    fail_img_dir: Path,
    conf_th: float = 0.7,
    allow_empty_boxes_pass: bool = True,
    device: str = "0",
    copy_mode: str = "copy",
    ...
) -> dict:
    """
    Student 모델로 이미지 추론 후 PASS/FAIL 분류

    PASS 조건:
    - allow_empty_boxes_pass=True: 빈 박스도 PASS (고신뢰 검출 불필요)
    - allow_empty_boxes_pass=False: conf >= conf_th인 박스 1개 이상

    Returns:
        {"pass": 450, "fail": 50, "used_imgs": 500}
    """
```

---

#### 2) `run_teacher_on_fail()` - Teacher 추론

**파일:** `auto_labeling/v_1/src/teacher_runner.py` (또는 `teacher_runner_DINO.py`)

```python
def run_teacher_on_fail(
    fail_img_dir: Path,
    out_label_dir: Path,
    teacher_weights: Optional[Path] = None,
    device: Optional[str] = None,
    max_fail_samples: Optional[int] = None,
    conf_th: float = 0.5
) -> List[Path]:
    """
    Teacher 모델로 FAIL 이미지 추론

    Teacher 설정은 configs/teacher_model.yaml에서 로드:
    - weights_uri: 모델 경로 (로컬 또는 MinIO)
    - device: GPU 장치 번호
    - conf_th: 신뢰도 임계값

    Returns:
        Teacher가 성공적으로 라벨링한 이미지 경로 리스트
        (conf >= conf_th인 박스 1개 이상)
    """
```

---

#### 3) `train_on_teacher_pseudo()` - Student 재학습

**파일:** `auto_labeling/v_1/src/yolo_mini_trainer.py`

```python
def train_on_teacher_pseudo(
    base_weights: Path,
    img_dir: Path,
    label_dir: Path,
    out_weights: Optional[Path] = None,
    round_index: int = 0,
    sampler: str = "fail_only",
    anchor_ratio: int = 5,
    epochs: int = 2,
    imgsz: int = 640,
    device: str = "0",
    lr0: float = 5e-5,
    freeze_backbone: bool = True,
    freeze_layers: int = 10,
    batch: Optional[int] = None,
    workers: Optional[int] = None
) -> Path:
    """
    Teacher 라벨 + GT Anchor로 Student 재학습 (Micro Fine-tuning)

    특징:
    - Backbone Freeze (freeze_layers=10)
    - 낮은 Learning Rate (lr0=5e-5)
    - 적은 Epochs (2)
    - 작은 Batch (GPU 메모리 효율)

    Returns:
        새 Student 모델 경로
    """
```

---

## 7. 이벤트 및 상태 관리

### 7.1 이벤트 로그 구조

```
logs/events/<runId>/
├── 20250106_120000_000001_LOOP_STARTED.json
├── 20250106_120530_000002_ROUND_STARTED.json
├── 20250106_121000_000003_LOOP_PROGRESS.json
├── 20250106_121500_000004_ROUND_COMPLETED.json
├── 20250106_122000_000005_LOOP_PROGRESS.json
└── 20250106_123000_000006_LOOP_COMPLETED.json
```

**파일명 형식:** `<timestamp>_<eventType>.json`

**파일 내용:**
```json
{
  "receivedAt": "2025-01-06T12:30:00Z",
  "event": {
    "eventType": "LOOP_PROGRESS",
    "runId": "run_20250106_120000_xyz789",
    "data": {
      "currentRound": 1,
      "totalRounds": 3,
      "failRatio": 0.25,
      "passCount": 375,
      "failCount": 125,
      "message": "Round 1 completed"
    }
  }
}
```

---

### 7.2 이벤트 타입

```python
class EventType(str, Enum):
    LOOP_STARTED = "LOOP_STARTED"
    LOOP_PROGRESS = "LOOP_PROGRESS"
    LOOP_COMPLETED = "LOOP_COMPLETED"
    LOOP_FAILED = "LOOP_FAILED"
    ROUND_STARTED = "ROUND_STARTED"
    ROUND_COMPLETED = "ROUND_COMPLETED"
    EXPORT_STARTED = "EXPORT_STARTED"
    EXPORT_COMPLETED = "EXPORT_COMPLETED"
```

---

### 7.3 Worker 이벤트 콜백

**파일:** `auto_labeling/v_1/worker/services/events_client.py`

```python
def send_event(event_type: EventType, run_id: str, data: dict):
    """
    API Server로 이벤트 전송

    POST {API_BASE_URL}/api/v1/events
    {
      "eventType": "LOOP_PROGRESS",
      "runId": "run_xxx",
      "data": {...}
    }
    """
    url = f"{API_BASE_URL}/api/v1/events"
    requests.post(url, json={
        "eventType": event_type,
        "runId": run_id,
        "data": data
    })
```

**사용 예시:**
```python
# Loop 시작
send_event("LOOP_STARTED", run_id, {
    "studentWeights": str(student_w),
    "failImgDir": str(fail_img_dir),
    "maxRounds": max_rounds
})

# 라운드 완료
send_event("ROUND_COMPLETED", run_id, {
    "round": r,
    "passCount": n_pass,
    "failCount": n_fail,
    "failRatio": fail_ratio,
    "teacherSuccess": len(teacher_success_imgs),
    "teacherMiss": len(teacher_miss_imgs)
})
```

---

## 8. 설계.md와의 차이점

### 8.1 시스템 구조

| 항목 | 설계.md (3모델 앙상블) | 실제 v_1 구현 (Student-Teacher) |
|------|----------------------|-------------------------------|
| **모델 구성** | 3개 독립 모델 (YOLO, Model2, Model3) | 2개 협력 모델 (Student, Teacher) |
| **추론 방식** | 3개 모델 병렬 추론 → 앙상블 | Student 추론 → FAIL만 Teacher 추론 |
| **결과 분류** | PASS_THREE, PASS_TWO, FAIL, MISS | PASS, FAIL, MISS |
| **학습 방식** | 모델별 독립 학습 (GT 고정) | Student 반복 학습 (Teacher 라벨 활용) |

---

### 8.2 API 구조

| 항목 | 설계.md | 실제 v_1 |
|------|---------|---------|
| **GT 업로드** | `/api/v1/{model}/gt/download` (모델별) | `/api/v1/gt/ingests/upload` (단일) |
| **GT 등록** | `/api/v1/{model}/register` | `/api/v1/gt/ingests/{id}/register` |
| **Loop 시작** | `/api/v1/loop/start` | `/api/v1/loop/run` (Worker 프록시) |
| **Loop 상태** | `/api/v1/event/{loop_id}` (폴링) | `/api/v1/loop/status/{job_id}` + `/api/v1/events/latest` (폴링) |
| **Export** | `/api/v1/export/{loop_id}/run/{run_number}` | `/api/v1/export/round0`, `/api/v1/export/final` |

---

### 8.3 데이터 흐름

#### 설계.md (앙상블)
```
Unlabeled 이미지
    ↓
Model 1 추론 → PASS/FAIL
Model 2 추론 → PASS/FAIL
Model 3 추론 → PASS/FAIL
    ↓
앙상블:
- 3개 PASS → PASS_THREE
- 2개 PASS → PASS_TWO
- 1개 PASS → FAIL
- 0개 PASS → MISS
    ↓
결과 Export (1회)
```

#### 실제 v_1 (Iterative Loop)
```
Unlabeled 이미지
    ↓
Student 추론 → PASS/FAIL
    ↓
PASS → 완료
FAIL → Teacher 추론
    ↓
Teacher SUCCESS → Student 재학습
Teacher MISS → MISS
    ↓
새 Student로 FAIL 재추론 (Round 반복)
    ↓
수렴 시 종료 → Export
```

---

### 8.4 상태 관리

| 항목 | 설계.md | 실제 v_1 |
|------|---------|---------|
| **상태 저장** | JSON 파일 (`loop_{id}.json`, `run_{id}.json`) | 이벤트 로그 (타임스탬프 기반 JSON 파일) |
| **폴링 방식** | JSON 파일 직접 읽기 | 이벤트 로그 최신 파일 읽기 |
| **진행 상황** | Loop/Run 단위 상태 | Event 단위 로그 |

---

### 8.5 핵심 설계 차이 요약

#### 신규 설계 (3모델 앙상블 + Round 반복)의 특징
- **앙상블 신뢰도**: 3개 모델의 다수결로 높은 정확도
- **점진 개선**: FAIL+MISS 재추론으로 품질 향상 (Round 반복)
- **투명성**: 3개 모델의 독립적인 판단 확인 가능
- **병렬성**: 3개 모델 동시 추론 가능
- **유연성**: 모델별 독립 학습 및 교체 가능

#### 기존 v_1 (Student-Teacher)과의 차이점
- **모델 구조**: 2개 협력 모델 → 3개 독립 모델
- **추론 방식**: 순차 (Student → Teacher) → 병렬 (3개 동시)
- **결과 분류**: PASS/FAIL/MISS → PASS_THREE/TWO/FAIL/MISS (4단계 신뢰도)
- **학습 방식**: Student 반복 학습 → 모델별 독립 학습 (GT 고정)
- **비용**: FAIL만 Teacher 추론 → 모든 이미지 3모델 추론 (비용 증가)

---

## 9. 주요 설정 파일

### 9.1 Ensemble Loop 설정 (`configs/ensemble_config.yaml`)

```yaml
ensemble:
  # 모델 구성
  models:
    - name: "yolo"
      weights_uri: "models/yolo_best.pt"
      format: "yolo"  # yolo | coco
      device: "0"
      conf_threshold: 0.5

    - name: "model2"
      weights_uri: "models/model2_best.pt"
      format: "coco"
      device: "0"
      conf_threshold: 0.5

    - name: "model3"
      weights_uri: "models/model3_best.pt"
      format: "coco"
      device: "0"
      conf_threshold: 0.5

  # Round 반복 설정
  max_rounds: 4
  fail_threshold: 0.01          # FAIL+MISS 비율 임계값 (1%)
  min_fail_count: 100           # FAIL+MISS 개수 임계값
  patience: 2                   # 개선 없을 시 조기 종료

  # Bbox 병합 설정
  iou_threshold: 0.5            # NMS IoU 임계값
  merge_strategy: "average"     # average | weighted

  # 성능 최적화
  parallel_inference: true      # 3개 모델 병렬 추론
  batch_size: 16                # 각 모델당 배치 크기
  num_workers: 4

  # GPU 메모리 관리
  gpu_memory_strategy: "parallel"  # parallel | sequential
  # parallel: 3개 모델 동시 로드 (12GB+ GPU 필요)
  # sequential: 1개씩 로드 후 추론 (8GB GPU 가능, 느림)

  # 파일 처리
  copy_mode: "symlink"          # symlink | copy | hardlink
```

---

### 9.2 클래스 정의 (`configs/classes.yaml`)

```yaml
names:
  0: "vehicle"
  1: "person"
  2: "debris"
```

---

### 9.3 GPU 메모리 추정

| 구성 | VRAM 사용량 | 추론 속도 | 권장 GPU |
|------|-----------|---------|---------|
| **병렬 (3모델 동시)** | ~12GB | 빠름 (1.0x) | RTX 3090, A100 |
| **순차 (1모델씩)** | ~4GB | 느림 (3.0x) | RTX 3060 |
| **하이브리드 (2+1)** | ~8GB | 중간 (1.5x) | RTX 3080 |

**추천 설정:**
- RTX 3090 (24GB): `parallel`, batch_size=32
- RTX 3080 (10GB): `sequential`, batch_size=16
- RTX 3060 (12GB): `parallel`, batch_size=8

---

## 10. Round 반복 전략 및 종료 조건

### 10.1 Round 반복의 목적

**왜 Round를 반복하는가?**
- Round 0에서 FAIL로 분류된 이미지들로 모델을 재학습
- 재학습된 모델은 이전에 실패했던 패턴을 학습하여 성능 개선
- **전체 Unlabeled 재추론**: 재학습된 모델로 모든 이미지를 재평가
- 각 Round마다 모델이 점진적으로 개선되어 FAIL 비율 감소

**재학습 + 전체 재추론 전략:**
- Round 1+마다 다음 과정 수행:
  1. **재학습**: 이전 Round의 FAIL 데이터 + GT Anchor로 Fine-tuning
  2. **전체 재추론**: 재학습된 모델로 **모든 Unlabeled** 이미지 재추론
  3. **재평가**: 이전에 PASS였던 이미지도 재학습된 모델로 다시 판정
- 모델이 개선될수록 PASS_THREE, PASS_TWO 비율 증가

### 10.2 종료 조건 상세

**현재 구현:**
- Round 0, 1, 2까지 **고정** (총 3회 실행)
- Round 2 완료 후 무조건 종료

**향후 확장 가능한 동적 종료 조건:**

Loop는 다음 조건 중 **하나라도 만족**하면 종료:

1. **max_rounds 도달**
   - 설정된 최대 Round 수에 도달
   - 무한 반복 방지

2. **FAIL+MISS 비율 < fail_threshold**
   - 전체 이미지 대비 실패율이 임계값 미만
   - 예: 1% 미만이면 충분히 좋은 결과로 판단

3. **FAIL+MISS 개수 < min_fail_count**
   - 절대 개수가 임계값 미만
   - 예: 100장 미만이면 허용 가능한 수준

4. **개선 없음 (patience)**
   - 연속 N Round 동안 FAIL+MISS 비율이 거의 개선 안됨
   - 더 이상 재학습 효과 없음으로 판단

5. **FAIL+MISS 0개**
   - 모든 이미지가 PASS로 전환 (이상적인 케이스)

**예시 (동적 종료 적용 시):**
```
Round 0: 1000장 재추론 → FAIL+MISS 150장 (15%)
Round 1: 1000장 재추론 → FAIL+MISS  80장 (8% → 개선폭 7%)
Round 2: 1000장 재추론 → FAIL+MISS  40장 (4% → 개선폭 4%)
Round 3: 1000장 재추론 → FAIL+MISS  38장 (3.8% → 개선폭 0.2%, patience 카운트)
Round 4: 1000장 재추론 → FAIL+MISS  37장 (3.7% → 개선폭 0.1%, patience 2 도달)
→ 조기 종료 (또는 현재는 Round 2에서 종료)
```

---

## 11. 배포 구조

### 11.1 Docker Compose 예시

```yaml
version: '3.8'

services:
  v1-api:
    build: .
    container_name: v1-api
    ports:
      - "8010:8010"
    volumes:
      - ./auto_labeling/v_1:/workspace/auto_labeling/v_1
    environment:
      - WORKER_BASE_URL=http://v1-worker:8011
    command: uvicorn auto_labeling.v_1.api.server:app --host 0.0.0.0 --port 8010

  v1-worker:
    build: .
    container_name: v1-worker
    ports:
      - "8011:8011"
    volumes:
      - ./auto_labeling/v_1:/workspace/auto_labeling/v_1
    environment:
      - API_BASE_URL=http://v1-api:8010
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    command: uvicorn auto_labeling.v_1.worker.server:app --host 0.0.0.0 --port 8011
```

---

## 12. 확장 및 개선 방향

### 12.1 앙상블 전략 개선
- **가중 평균 (Weighted Ensemble)**: 모델별 성능에 따라 가중치 부여
- **Soft Voting**: 신뢰도 점수 기반 앙상블 (현재는 Hard Voting)
- **학습 기반 앙상블**: 메타 모델을 학습하여 3개 모델 결과 통합

### 12.2 성능 최적화
- **모델 추론 결과 캐싱**: 동일 이미지 재추론 방지
- **배치 크기 동적 조정**: GPU 메모리 사용률에 따라 자동 조정
- **TensorRT 변환**: 추론 속도 2-3배 향상
- **Mixed Precision (FP16)**: VRAM 사용량 50% 감소

### 12.3 모니터링 강화
- **Prometheus + Grafana 연동**:
  - Round별 PASS/FAIL/MISS 비율 차트
  - GPU 메모리/사용률 실시간 모니터링
  - 추론 속도 (images/sec) 추적
- **평가 지표 자동 계산**:
  - mAP, Precision, Recall (GT 대비)
  - 모델별 성능 비교 대시보드
  - FAIL 샘플 분포 히트맵

### 12.4 확장성
- **Multi-GPU 분산 추론**:
  - 각 모델을 별도 GPU에 할당 (YOLO: GPU0, M2: GPU1, M3: GPU2)
  - 배치 분산 처리로 처리량 3배 향상
- **Kubernetes 배포**:
  - Worker Pod 자동 스케일링
  - GPU 노드 동적 할당
- **클라우드 스토리지**:
  - MinIO 클러스터 연동
  - S3 호환 스토리지 지원

### 12.5 모델 관리
- **모델 버전 관리**: 각 모델의 weights 버전 추적
- **A/B 테스트**: 신규 모델과 기존 모델 성능 비교
- **Hot Swap**: 서비스 중단 없이 모델 교체

---

## 13. 참고 자료

### 13.1 핵심 파일 경로 (신규)
- Ensemble 서비스: `auto_labeling/v_1/src/ensemble_service.py` (신규)
- Bbox 병합: `auto_labeling/v_1/src/bbox_merger.py` (신규)
- 모델 추론: `auto_labeling/v_1/src/model_inference.py` (신규)
- API 라우터: `auto_labeling/v_1/api/routers/*.py` (수정)
- Worker 라우터: `auto_labeling/v_1/worker/routers/loop_worker.py` (대폭 수정)

### 13.2 설정 파일
- Ensemble: `auto_labeling/v_1/configs/ensemble_config.yaml` (신규)
- Classes: `auto_labeling/v_1/configs/classes.yaml` (유지)

### 13.3 기존 파일 변경 사항
- ❌ **삭제 예정**:
  - `src/loop_controller.py` (Student-Teacher Loop)
  - `src/teacher_runner.py`
  - `src/yolo_mini_trainer.py`
  - `configs/v1_loop_real.yaml`
  - `configs/teacher_model.yaml`

- ⚠️ **대폭 수정**:
  - `api/routers/loop.py` (API 엔드포인트 변경)
  - `worker/routers/loop_worker.py` (앙상블 로직 적용)

- ✅ **재사용**:
  - `api/routers/events.py` (변경 없음)
  - `api/routers/logs.py` (변경 없음)
  - `storage/minio_client.py` (변경 없음)
  - `src/gt_register.py` (모델별 경로만 수정)

---

---

## 9. 마이그레이션 계획 (FastAPI API 서버)

> **중요**: 이 계획은 **FastAPI API 서버만** 담당합니다. Worker 구현은 다른 개발자가 담당합니다.

### 9.1 전환 목표
현재 v_1의 **Student-Teacher Loop 방식**을 **3모델 앙상블 방식**으로 전환

### 9.2 역할 분담

| 구분 | 담당 | 구현 범위 |
|------|------|----------|
| **API Server** | 본인 (FastAPI) | - GT/Unlabeled 업로드/등록 API<br/>- Loop 시작/상태 조회 API (Worker 프록시)<br/>- 이벤트 수신/조회 API<br/>- Export API<br/>- 결과 프리뷰 API |
| **Worker Server** | 다른 개발자 | - 앙상블 서비스 (`ensemble_service.py`)<br/>- 모델 추론 (`yolo_model.py`, `coco_model.py`)<br/>- Loop 실행 워커 (`loop_worker.py`)<br/>- Bbox 병합 로직 |

### 9.3 API 서버 주요 변경 사항

#### A. 데이터 구조 변경

**기존 (Student-Teacher)**
```
data/
├── GT/                    # 단일 GT
├── unlabeled/images/      # 단일 Unlabeled
├── fail/images/           # FAIL 이미지
└── round_r0/              # Loop 라운드별 결과
```

**신규 (3모델 앙상블)**
```
data/
├── gt_data/
│   ├── yolo/
│   │   ├── GT_202601/
│   │   └── GT.file        # 현재 활성 GT (심볼릭 링크)
│   ├── model2/
│   └── model3/
├── unlabeled/
│   ├── yolo/
│   ├── model2/
│   └── model3/
└── results/
    └── loop_{loop_id}/
        └── run_{run_id}_0/
            ├── PASS_THREE/
            ├── PASS_TWO/
            ├── FAIL/
            └── MISS/
```

---

#### B. API 엔드포인트 변경

| 기능 | 기존 API | 신규 API (모델별) |
|------|---------|------------------|
| GT 업로드 | `/gt/ingests/upload` | `/api/v1/{model}/gt/download` |
| GT 등록 | `/gt/ingests/{id}/register` | `/api/v1/{model}/register` |
| Unlabeled 업로드 | `/unlabeled/ingests/upload` | `/api/v1/{model}/unlabel/upload` |
| Loop 시작 | `/loop/run` | `/api/v1/loop/start` |
| Loop 상태 | `/loop/status/{jobId}` | `/api/v1/event/{loop_id}` |
| Export | `/export/round0`, `/export/final` | `/api/v1/export/{loop_id}/run/{run_number}` |

---

#### C. 핵심 로직 변경

**기존: `loop_controller.py`**
```python
# Student-Teacher Iterative Loop
for round in range(max_rounds):
    # 1. Student PASS/FAIL
    split_pass_fail(student_w, fail_imgs)

    # 2. Teacher on FAIL
    teacher_labels = run_teacher_on_fail(fail_sample)

    # 3. Student 재학습
    student_w = train_on_teacher_pseudo(teacher_labels + gt_anchor)

    # 4. 다음 라운드 (FAIL 잔존분)
```

**신규: `ensemble_service.py` (새로 작성)**
```python
# 3모델 병렬 추론 + 앙상블 (1회)
def run_ensemble(models, unlabeled_batches):
    # 1. 3개 모델 병렬 추론
    yolo_preds = model_yolo.predict(unlabeled_batches)
    model2_preds = model2.predict(unlabeled_batches)
    model3_preds = model3.predict(unlabeled_batches)

    # 2. 앙상블 분류
    for img in unlabeled_batches:
        pass_count = sum([
            yolo_preds[img] == "PASS",
            model2_preds[img] == "PASS",
            model3_preds[img] == "PASS"
        ])

        if pass_count == 3:
            result = "PASS_THREE"
        elif pass_count == 2:
            result = "PASS_TWO"
        elif pass_count == 1:
            result = "FAIL"
        else:
            result = "MISS"

    # 3. 결과 저장 (1회 완료)
    save_ensemble_results(results)
```

---

### 9.4 FastAPI API 서버 구현 단계

#### Phase 1: DTO 및 데이터 구조 준비 (1일)

**작업 내용:**
- [ ] 앙상블 관련 DTO 클래스 작성
- [ ] 데이터 디렉토리 구조 문서화
- [ ] 기존 DTO 검토 및 재사용 가능 항목 확인

**파일:**
- `auto_labeling/v_2/api/dto/ensemble.py` (신규)
  ```python
  from pydantic import BaseModel, Field

  class EnsembleLoopRequest(BaseModel):
      models: list[str] = Field(default=["yolo", "model2", "model3"])
      configOverride: dict | None = None

  class EnsembleLoopResponse(BaseModel):
      loopId: str
      runId: str
      status: str

  class RoundResult(BaseModel):
      round: int
      total: int
      passThree: int
      passTwo: int
      fail: int
      miss: int
      failMissRatio: float
  ```

- `auto_labeling/v_2/api/dto/export_ensemble.py` (신규)
  ```python
  class ExportRoundRequest(BaseModel):
      loopId: str
      runNumber: int

  class ExportFinalRequest(BaseModel):
      loopId: str
  ```

**기존 DTO 재사용:**
- ✅ `api/dto/event.py` (이벤트) - 변경 없음
- ✅ `api/dto/common.py` (공통) - 변경 없음
- ✅ `api/dto/log.py` (로그) - 변경 없음

---

#### Phase 2: 모델별 GT/Unlabeled API 구현 (2일)

**작업 내용:**
- [ ] 모델별 GT 업로드 API
- [ ] 모델별 GT 등록 API (GT.file 심볼릭 링크)
- [ ] 모델별 Unlabeled 업로드 API
- [ ] GT 버전 목록 조회 API

**신규 파일:**
- `auto_labeling/v_2/api/routers/gt_model.py`
  ```python
  from fastapi import APIRouter, UploadFile, File, Path as PathParam

  router = APIRouter(prefix="/api/v1/{model}")

  @router.post("/gt/download")
  async def upload_gt_by_model(
      model: str = PathParam(...),
      file: UploadFile = File(...)
  ):
      # 모델별 GT 업로드
      # data/gt_data/{model}/GT_{timestamp}/ 에 저장
      pass

  @router.post("/register")
  async def register_gt_by_model(
      model: str = PathParam(...),
      gt_version: str
  ):
      # GT.file 심볼릭 링크 생성
      # data/gt_data/{model}/GT.file → GT_{version}
      pass

  @router.get("/gt/versions")
  async def list_gt_versions(
      model: str = PathParam(...)
  ):
      # GT 버전 목록 반환
      pass
  ```

- `auto_labeling/v_2/api/routers/unlabel_model.py`
  ```python
  @router.post("/api/v1/{model}/unlabel/upload")
  async def upload_unlabeled_by_model(
      model: str = PathParam(...),
      file: UploadFile = File(...)
  ):
      # data/unlabeled/{model}/images/ 에 저장
      pass
  ```

**재사용 가능 로직:**
- ✅ `src/gt_register.py` 의 `register_gt_yolo()` - 모델별 경로만 변경

---

#### Phase 3: Loop API 구현 (Worker 프록시) (1일)

**작업 내용:**
- [ ] Loop 시작 API (Worker로 프록시)
- [ ] Loop 상태 조회 API (Worker로 프록시)
- [ ] 에러 처리 (Worker 응답 검증)

**수정 파일:**
- `auto_labeling/v_2/api/routers/loop.py`
  ```python
  @router.post("/loop/start")
  def start_loop(req: EnsembleLoopRequest):
      # Worker로 프록시
      url = f"{WORKER_BASE_URL}/api/v1/loop/start"
      response = requests.post(url, json=req.dict())
      return response.json()

  @router.get("/loop/status/{loop_id}")
  def get_loop_status(loop_id: str):
      # Worker로 프록시
      url = f"{WORKER_BASE_URL}/api/v1/loop/status/{loop_id}"
      response = requests.get(url)
      return response.json()
  ```

**재사용:**
- ✅ 기존 `api/routers/loop.py`의 프록시 로직 참고
- ✅ `_post_json_worker()`, `_get_json_worker()` 헬퍼 함수 재사용

---

#### Phase 4: 이벤트 API (변경 없음) (0.5일)

**작업 내용:**
- [ ] 기존 이벤트 API 검토
- [ ] Round 관련 이벤트 타입 추가 (필요시)

**파일:**
- ✅ `auto_labeling/v_2/api/routers/events.py` - **변경 없음**
- ⚠️ `api/dto/event.py` - 이벤트 타입 추가 (선택)
  ```python
  class EventType(str, Enum):
      LOOP_STARTED = "LOOP_STARTED"
      LOOP_PROGRESS = "LOOP_PROGRESS"
      LOOP_COMPLETED = "LOOP_COMPLETED"
      ROUND_STARTED = "ROUND_STARTED"
      ROUND_COMPLETED = "ROUND_COMPLETED"
      # ... 기존 타입 유지
  ```

---

#### Phase 5: Export API 구현 (2일)

**작업 내용:**
- [ ] Round별 Export API (`/export/{loop_id}/run/{run_number}`)
- [ ] Final Export API (`/export/{loop_id}/final`)
- [ ] ZIP 생성 로직 (PASS_THREE/TWO/FAIL/MISS → ZIP)
- [ ] 캐싱 로직 (재생성 방지)

**신규 파일:**
- `auto_labeling/v_2/api/routers/export_ensemble.py`
  ```python
  @router.get("/export/{loop_id}/run/{run_number}")
  def export_round(
      loop_id: str,
      run_number: int
  ):
      # data/results/loop_{loop_id}/run_{run_number}/ 를 ZIP으로
      # exports/{loop_id}/run_{run_number}.zip 캐싱
      pass

  @router.get("/export/{loop_id}/final")
  def export_final(
      loop_id: str
  ):
      # data/results/loop_{loop_id}/final/ 를 ZIP으로
      # exports/{loop_id}/final.zip 캐싱
      pass
  ```

- `auto_labeling/v_2/src/export_ensemble.py` (유틸리티)
  ```python
  def create_round_zip(loop_id: str, run_number: int) -> Path:
      # Round별 ZIP 생성
      pass

  def create_final_zip(loop_id: str) -> Path:
      # Final ZIP 생성 (모든 Round 병합)
      pass
  ```

**재사용:**
- ⚠️ `api/routers/export.py`의 ZIP 생성 로직 참고

---

#### Phase 6: 결과 프리뷰 API 구현 (1.5일)

**작업 내용:**
- [ ] Round별 프리뷰 생성 API
- [ ] Round별 프리뷰 조회 API
- [ ] 프리뷰 이미지 서빙 API

**신규 파일:**
- `auto_labeling/v_2/api/routers/results_ensemble.py`
  ```python
  @router.post("/results/round/{run_number}/buildPreviewSet")
  def build_round_preview(
      run_number: int,
      req: BuildPreviewRequest
  ):
      # data/results/loop_{loop_id}/run_{run_number}/ 에서 샘플링
      # logs/previews/{loop_id}/run_{run_number}/ 에 bbox 그린 이미지 저장
      pass

  @router.get("/results/round/{run_number}/preview")
  def get_round_preview(
      run_number: int,
      loop_id: str
  ):
      # 프리뷰 이미지 목록 반환
      pass
  ```

**재사용:**
- ⚠️ `api/routers/results.py`의 프리뷰 생성 로직 참고

---

#### Phase 7: API 문서 및 테스트 (1일)

**작업 내용:**
- [ ] Swagger/OpenAPI 문서 검토
- [ ] API 단위 테스트 작성
- [ ] Postman 컬렉션 업데이트

**테스트 파일:**
- `auto_labeling/v_2/test/api/test_gt_model.py` (신규)
- `auto_labeling/v_2/test/api/test_export_ensemble.py` (신규)

**테스트 항목:**
- ✅ GT 업로드 → 등록 → 버전 조회
- ✅ Unlabeled 업로드 (3개 모델)
- ✅ Loop 시작 → 상태 조회 (모킹)
- ✅ Export Round → Export Final
- ✅ 프리뷰 생성 → 조회

---

### 9.4 기존 코드 재사용 가능 항목

| 기능 | 기존 파일 | 재사용 여부 | 비고 |
|------|---------|-----------|------|
| GT 등록 | `src/gt_register.py` | ✅ 재사용 | 모델별 경로만 변경 |
| 이벤트 관리 | `api/routers/events.py` | ✅ 재사용 | 변경 없음 |
| 로그 관리 | `api/routers/logs.py` | ✅ 재사용 | 변경 없음 |
| MinIO 클라이언트 | `storage/minio_client.py` | ✅ 재사용 | 변경 없음 |
| DTO 클래스 | `api/dto/*.py` | ⚠️ 부분 수정 | 앙상블 관련 DTO 추가 |
| Loop 컨트롤러 | `src/loop_controller.py` | ❌ 대체 | `ensemble_service.py`로 대체 |
| PASS/FAIL 필터 | `src/pass_fail_filter.py` | ⚠️ 참고 | 앙상블 로직에 통합 |
| Teacher 러너 | `src/teacher_runner.py` | ❌ 미사용 | 제거 |
| YOLO 트레이너 | `src/yolo_mini_trainer.py` | ❌ 미사용 | 제거 |

---

### 9.5 마이그레이션 체크리스트

**준비 단계**
- [ ] 기존 데이터 백업
- [ ] 새 브랜치 생성 (`feature/ensemble-migration`)
- [ ] 설계 문서 최종 검토

**개발 단계 (API Server - 본인 담당)**
- [ ] Phase 1: DTO 및 데이터 구조 (1일)
- [ ] Phase 2: 모델별 GT/Unlabeled API (2일)
- [ ] Phase 3: Loop API (Worker 프록시) (1일)
- [ ] Phase 4: 이벤트 API 검토 (0.5일)
- [ ] Phase 5: Export API (2일)
- [ ] Phase 6: 결과 프리뷰 API (1.5일)
- [ ] Phase 7: API 문서 및 테스트 (1일)

**Worker 개발 (다른 개발자 담당)**
- [ ] Ensemble 서비스 구현 (3일)
- [ ] 모델 추론 레이어 (2일)
- [ ] Bbox 병합 로직 (2일)
- [ ] Loop Worker (1일)

**통합 및 검증**
- [ ] API-Worker 통합 테스트 (1일)
- [ ] 성능 벤치마크 (GPU, 속도) (1일)
- [ ] 문서 업데이트 (0.5일)

**배포 단계**
- [ ] Staging 환경 테스트 (1일)
- [ ] Production 배포 (0.5일)
- [ ] 모니터링 설정 (0.5일)

**예상 소요 시간:**
- API Server (본인): 9일
- Worker (다른 개발자): 8일
- 통합 및 배포: 3일
- **총 12일** (병렬 작업 가능 시 실제 9일)

---

### 9.6 주의 사항

1. **하위 호환성**
   - 기존 이벤트 API는 유지 (Spring Boot 폴링 코드 변경 최소화)
   - 기존 데이터 디렉토리는 삭제하지 않고 병행 운영

2. **성능**
   - 3모델 병렬 추론 시 GPU 메모리 부족 가능
   - 배치 크기 조정 필요 (각 모델당 batch/3)

3. **에러 처리**
   - 특정 모델 실패 시 처리 방안
   - PASS 판정이 없을 경우 (3개 모두 MISS) 처리

4. **데이터 정합성**
   - 모델별 Unlabeled 이미지가 동일한지 검증
   - GT 버전 불일치 방지

---

## 10. 기존 v_1과의 차이점 (상세)

### 10.1 시스템 구조

| 항목 | 기존 v_1 (Student-Teacher) | 신규 (3모델 앙상블) |
|------|--------------------------|-------------------|
| **모델 구성** | 2개 협력 (Student, Teacher) | 3개 독립 (YOLO, M2, M3) |
| **추론 방식** | 순차 (Student → FAIL → Teacher) | 병렬 (3개 동시) |
| **결과 분류** | PASS, FAIL, MISS | PASS_THREE, PASS_TWO, FAIL, MISS |
| **학습 방식** | Student 반복 학습 (Teacher 라벨 활용) | 모델별 독립 학습 (GT 고정) |
| **실행 횟수** | 반복 (max_rounds) | 1회 (Loop 없음) |
| **데이터 관리** | 단일 GT/Unlabeled | 모델별 GT/Unlabeled |

### 10.2 장단점 비교

#### 기존 v_1 (Student-Teacher) 장점
- ✅ 비용 효율: FAIL만 Teacher 추론
- ✅ 점진 개선: Loop로 품질 향상
- ✅ 확장성: 다양한 Teacher 적용 가능

#### 기존 v_1 단점
- ❌ 복잡도: Loop 로직 관리
- ❌ 시간: 여러 라운드 반복 (순차 처리)
- ❌ 불확실성: 수렴 보장 어려움
- ❌ 투명성: Teacher 의존도 높음

#### 신규 (3모델 앙상블 + Round 반복) 장점
- ✅ 높은 신뢰도: 3개 모델 다수결로 정확도 향상
- ✅ 투명성: 각 모델의 독립적 판단 확인 가능
- ✅ 병렬성: 3개 모델 동시 추론 (속도 향상)
- ✅ 점진 개선: Round 반복으로 FAIL 감소
- ✅ 유연성: 모델별 독립 학습 및 교체 용이

#### 신규 단점
- ❌ 비용: 모든 이미지를 3개 모델로 추론 (계산 비용 3배)
- ❌ GPU 메모리: 3개 모델 동시 로드 시 12GB+ 필요
- ❌ 초기 설정: 3개 모델 사전 학습 필요
- ❌ 복잡도: Bbox 병합 로직 (NMS, 좌표계 통일) 추가

---

## 결론

이 설계는 **설계.md의 3모델 앙상블 방식**에 **Round 반복 전략**을 추가하여, **현재 v_1의 인프라 (API/Worker 분리, 이벤트 로그)**에 적용하는 것을 목표로 합니다.

### 핵심 특징
1. **3모델 앙상블**: YOLO + Model2 + Model3 병렬 추론으로 높은 신뢰도 확보
2. **Round 반복 전략**: FAIL+MISS 재추론으로 점진적 품질 향상
3. **4단계 신뢰도 분류**: PASS_THREE/TWO/FAIL/MISS로 세밀한 결과 관리
4. **파일 기반 상태 관리**: Redis/WebSocket 없이 이벤트 로그로 폴링 (유지)
5. **모델별 독립 관리**: GT/Unlabeled 데이터 분리, 모델 교체 용이
6. **Worker 분리**: API/Worker 서버 분리로 확장성 확보 (유지)
7. **멱등성 보장**: GET은 조회만, POST로 결과 생성 (유지)
8. **NMS + 좌표계 통일**: 정교한 Bbox 병합 로직

### 기존 v_1 대비 주요 개선점
- **정확도**: 3개 모델 다수결로 오검출 감소
- **투명성**: 각 모델의 판단 근거 추적 가능
- **확장성**: 모델 추가/교체 용이 (4모델, 5모델 확장 가능)
- **병렬 처리**: 3개 모델 동시 추론으로 처리 시간 단축 (GPU 충분 시)

### 트레이드오프
- **비용 증가**: 계산 비용 3배 (모든 이미지를 3개 모델로 추론)
- **GPU 요구사항**: 병렬 처리 시 12GB+ VRAM 필요
- **초기 설정**: 3개 모델 사전 학습 필요

### 다음 단계
1. 설계 문서 최종 검토 및 승인
2. Phase 1부터 순차 개발 시작 (예상: 12일)
3. 테스트 데이터 준비 (소규모 GT/Unlabeled, 각 모델당)
4. GPU 환경 검증 (VRAM, 추론 속도 측정)
5. 기존 v_1 백업 및 브랜치 분리

이 문서는 3모델 앙상블 + Round 반복 방식으로의 마이그레이션 가이드이며, 단계별 개발 진행 시 참고 자료로 활용할 수 있습니다.
