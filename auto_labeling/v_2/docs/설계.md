# FastAPI AI ìë™ ë¼ë²¨ë§ ì‹œìŠ¤í…œ ì„¤ê³„ ë¬¸ì„œ (JSON ê¸°ë°˜ í´ë§ ë²„ì „)

## ğŸ“‹ ëª©ì°¨
1. [ì‹œìŠ¤í…œ ê°œìš”](#1-ì‹œìŠ¤í…œ-ê°œìš”)
2. [ì „ì²´ ì•„í‚¤í…ì²˜](#2-ì „ì²´-ì•„í‚¤í…ì²˜)
3. [í”„ë¡œì íŠ¸ êµ¬ì¡°](#3-í”„ë¡œì íŠ¸-êµ¬ì¡°)
4. [í•µì‹¬ API ì„¤ê³„](#4-í•µì‹¬-api-ì„¤ê³„)
5. [ë°ì´í„° íë¦„](#5-ë°ì´í„°-íë¦„)
6. [êµ¬í˜„ ì½”ë“œ](#6-êµ¬í˜„-ì½”ë“œ)
7. [ì„¤ì¹˜ ë° ì‹¤í–‰](#7-ì„¤ì¹˜-ë°-ì‹¤í–‰)
8. [íŠ¸ëŸ¬ë¸”ìŠˆíŒ…](#8-íŠ¸ëŸ¬ë¸”ìŠˆíŒ…)

---

## 1. ì‹œìŠ¤í…œ ê°œìš”

### 1.1 ì‹œìŠ¤í…œ ëª©ì 
êµí†µì‚¬ê³  í˜„ì¥ ë°ì´í„°ë¥¼ ìë™ìœ¼ë¡œ ë¼ë²¨ë§í•˜ëŠ” AI ê¸°ë°˜ ì‹œìŠ¤í…œìœ¼ë¡œ, 3ê°œì˜ AI ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ PASS/FAIL íŒì • ë° ì•™ìƒë¸”ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

### 1.2 ê¸°ìˆ  ìŠ¤íƒ
- **ë°±ì—”ë“œ**: FastAPI (Python 3.9+)
- **ë¹„ë™ê¸° ì‘ì—…**: Python Threading ë˜ëŠ” Celery (ì„ íƒ)
- **ìƒíƒœ ê´€ë¦¬**: JSON íŒŒì¼ ì‹œìŠ¤í…œ
- **í†µì‹  ë°©ì‹**: REST API + í´ë§
- **AI ëª¨ë¸**: YOLO, Custom Model 2, Custom Model 3
- **ì»¨í…Œì´ë„ˆ**: Docker + Docker Compose

### 1.3 í•µì‹¬ ì„¤ê³„ ì›ì¹™

#### âœ… **Redis, WebSocket, SSE ì‚¬ìš© ì•ˆ í•¨**
- ì§„í–‰ ìƒí™©ì€ **JSON íŒŒì¼**ì— ì €ì¥
- Spring Bootì—ì„œ **event APIë¥¼ í´ë§**í•˜ì—¬ ì§„í–‰ ìƒí™© ì¡°íšŒ
- ì™¸ë¶€ ì˜ì¡´ì„± ìµœì†Œí™”

#### ğŸ“ **íŒŒì¼ ê¸°ë°˜ ìƒíƒœ ê´€ë¦¬**
```
/data/status/
â”œâ”€â”€ loop_{loop_id}.json          # Loop ì „ì²´ ìƒíƒœ
â”œâ”€â”€ run_{run_id}.json            # ê° Round ìƒíƒœ
â””â”€â”€ logs/
    â”œâ”€â”€ model1.log
    â”œâ”€â”€ model2.log
    â””â”€â”€ model3.log
```

#### ğŸ”„ **í´ë§ ìµœì í™”**
- Spring BootëŠ” 2~3ì´ˆë§ˆë‹¤ event API í˜¸ì¶œ
- JSON íŒŒì¼ë§Œ ì½ê¸° (ë¹ ë¥¸ ì‘ë‹µ)
- íŒŒì¼ ë½(lock)ìœ¼ë¡œ ë™ì‹œì„± ì œì–´

---

## 2. ì „ì²´ ì•„í‚¤í…ì²˜

### 2.1 ì‹œìŠ¤í…œ êµ¬ì„±ë„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     React (Frontend)                         â”‚
â”‚   - ì‚¬ìš©ì UI                                                â”‚
â”‚   - íŒŒì¼ ì—…ë¡œë“œ                                              â”‚
â”‚   - ì§„í–‰ ìƒí™© í‘œì‹œ                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ HTTP REST API
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Spring Boot (Backend/ì¤‘ê³„)                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  ì£¼ìš” ì—­í• :                                        â”‚   â”‚
â”‚   â”‚  1. React â†” FastAPI ì¤‘ê³„                          â”‚   â”‚
â”‚   â”‚  2. ë°ì´í„° ë³€í™˜ ë° ì••ì¶•                            â”‚   â”‚
â”‚   â”‚  3. ì¸ì¦/ì¸ê°€                                      â”‚   â”‚
â”‚   â”‚  4. í´ë§ ê´€ë¦¬ (2~3ì´ˆë§ˆë‹¤ event API í˜¸ì¶œ)          â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚ HTTP REST API
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   FastAPI (AI Server)                        â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚          REST API Layer                             â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚   â”‚
â”‚  â”‚  â”‚ ë°ì´í„° ì¤€ë¹„   â”‚  â”‚    Loop      â”‚                â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”‚   â”‚
â”‚  â”‚  â”‚GT Download   â”‚  â”‚Loop Start    â”‚                â”‚   â”‚
â”‚  â”‚  â”‚Register      â”‚  â”‚Loop Stop     â”‚                â”‚   â”‚
â”‚  â”‚  â”‚Unlabel Uploadâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚   â”‚
â”‚  â”‚  â”‚   Export     â”‚  â”‚    Utils     â”‚                â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                â”‚   â”‚
â”‚  â”‚  â”‚Export        â”‚  â”‚Event (í´ë§)  â”‚                â”‚   â”‚
â”‚  â”‚  â”‚Export Final  â”‚  â”‚Log           â”‚                â”‚   â”‚
â”‚  â”‚  â”‚              â”‚  â”‚Switch        â”‚                â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         ë¹„ë™ê¸° ì‘ì—… Layer (Threading)               â”‚   â”‚
â”‚  â”‚  - Loop ì‹¤í–‰ (ë³„ë„ Thread)                         â”‚   â”‚
â”‚  â”‚  - JSON íŒŒì¼ì— ì§„í–‰ ìƒí™© ì €ì¥                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚           AI Model Layer                            â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚   â”‚
â”‚  â”‚  â”‚  YOLO    â”‚  â”‚ Model 2  â”‚  â”‚ Model 3  â”‚         â”‚   â”‚
â”‚  â”‚  â”‚  (.pt)   â”‚  â”‚  (COCO)  â”‚  â”‚  (COCO)  â”‚         â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚  ê° ëª¨ë¸ ì¶œë ¥: PASS / FAIL                          â”‚   â”‚
â”‚  â”‚  ì•™ìƒë¸” ê²°ê³¼: PASS_THREE, PASS_TWO, FAIL, MISS     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              File Storage (Local/NAS)                        â”‚
â”‚                                                              â”‚
â”‚  /data/                                                      â”‚
â”‚  â”œâ”€â”€ gt_data/          (GT ë°ì´í„°)                          â”‚
â”‚  â”œâ”€â”€ unlabeled/        (ì¶”ë¡ ìš© ì´ë¯¸ì§€)                      â”‚
â”‚  â”œâ”€â”€ results/          (Loop ê²°ê³¼)                          â”‚
â”‚  â”œâ”€â”€ status/           (ì§„í–‰ ìƒí™© JSON)  â­ í•µì‹¬           â”‚
â”‚  â””â”€â”€ logs/             (ë¡œê·¸ íŒŒì¼)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 í´ë§ íë¦„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Spring Boot â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ â”‚  í´ë§ ë£¨í”„ (2~3ì´ˆë§ˆë‹¤)         â”‚
       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ HTTP GET /api/v1/event/{loop_id}
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   FastAPI   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 1. JSON íŒŒì¼ ì½ê¸°
       â”‚    /data/status/loop_{loop_id}.json
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  JSON íŒŒì¼       â”‚
â”‚  {               â”‚
â”‚    "status": "RUNNING",
â”‚    "current_run": 2,
â”‚    "total_runs": 4,
â”‚    ...
â”‚  }               â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 2. JSON ë°ì´í„° ë°˜í™˜
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Spring Boot â”‚ â†’ React UI ì—…ë°ì´íŠ¸
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Loop ì‹¤í–‰ íë¦„
```
[Loop Start API í˜¸ì¶œ]
       â”‚
       â”œâ”€ loop_id ìƒì„±
       â”œâ”€ ì´ˆê¸° JSON íŒŒì¼ ìƒì„±
       â”‚  /data/status/loop_{loop_id}.json
       â”‚
       â”œâ”€ ë³„ë„ Thread/Processì—ì„œ Loop ì‹¤í–‰
       â”‚
       â””â”€ ì¦‰ì‹œ ì‘ë‹µ (loop_id ë°˜í™˜)

[ë³„ë„ Threadì—ì„œ Loop ì‹¤í–‰]
       â”‚
       â”œâ”€ Run 0 (Round 0)
       â”‚  â”œâ”€ run_id ìƒì„±
       â”‚  â”œâ”€ run_{run_id}.json ìƒì„±
       â”‚  â”‚
       â”‚  â”œâ”€ Model 1 ì¶”ë¡  â†’ PASS/FAIL
       â”‚  â”œâ”€ Model 2 ì¶”ë¡  â†’ PASS/FAIL
       â”‚  â”œâ”€ Model 3 ì¶”ë¡  â†’ PASS/FAIL
       â”‚  â”‚
       â”‚  â”œâ”€ ì•™ìƒë¸”
       â”‚  â”‚  â”œâ”€ PASS_THREE (3ê°œ ëª¨ë‘ PASS)
       â”‚  â”‚  â”œâ”€ PASS_TWO (2ê°œ PASS, 1ê°œ FAIL)
       â”‚  â”‚  â”œâ”€ FAIL (1ê°œ ì´í•˜ PASS)
       â”‚  â”‚  â””â”€ MISS (ê²€ì¶œ ì‹¤íŒ¨)
       â”‚  â”‚
       â”‚  â”œâ”€ ê²°ê³¼ ì €ì¥
       â”‚  â”‚  /data/results/loop_{loop_id}/run_{run_id}/
       â”‚  â”‚
       â”‚  â””â”€ JSON ì—…ë°ì´íŠ¸
       â”‚
       â”œâ”€ Run 1 (Round 1)
       â”‚  â””â”€ (ë™ì¼ ê³¼ì • ë°˜ë³µ)
       â”‚
       â””â”€ ì™„ë£Œ
          â””â”€ loop_{loop_id}.json ìƒíƒœ â†’ COMPLETED
```

---

## 3. í”„ë¡œì íŠ¸ êµ¬ì¡°

### 3.1 ë””ë ‰í† ë¦¬ êµ¬ì¡°
```
fastapi_ai/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ main.py                          # FastAPI ì•± ì—”íŠ¸ë¦¬í¬ì¸íŠ¸
â”‚   â”œâ”€â”€ config.py                        # ì„¤ì •
â”‚   â”‚
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ v1/
â”‚   â”‚       â”œâ”€â”€ router.py
â”‚   â”‚       â””â”€â”€ endpoints/
â”‚   â”‚           â”œâ”€â”€ gt_download.py       # GT ì—…ë¡œë“œ (ëª¨ë¸ë³„)
â”‚   â”‚           â”œâ”€â”€ register.py          # GT ë“±ë¡ (ëª¨ë¸ë³„)
â”‚   â”‚           â”œâ”€â”€ unlabel_upload.py    # Unlabel ì—…ë¡œë“œ (ëª¨ë¸ë³„)
â”‚   â”‚           â”œâ”€â”€ loop.py              # Loop ì‹œì‘/ì¤‘ì§€
â”‚   â”‚           â”œâ”€â”€ event.py             # í´ë§ìš© ì§„í–‰ ìƒí™© ì¡°íšŒ â­
â”‚   â”‚           â”œâ”€â”€ export.py            # ì¤‘ê°„ ì‚°ì¶œë¬¼ ì¡°íšŒ
â”‚   â”‚           â”œâ”€â”€ export_final.py      # ìµœì¢… ì‚°ì¶œë¬¼ ì¡°íšŒ
â”‚   â”‚           â”œâ”€â”€ log.py               # ë¡œê·¸ ì¡°íšŒ
â”‚   â”‚           â””â”€â”€ switch.py            # COCO â†” YOLO ë³€í™˜
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ gt_version_manager.py       # GT ë²„ì „ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ file_lock.py                # JSON íŒŒì¼ ë½ ê´€ë¦¬ â­
â”‚   â”‚
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ base_model.py               # ì¶”ìƒ ë² ì´ìŠ¤ í´ë˜ìŠ¤
â”‚   â”‚   â”œâ”€â”€ yolo_model.py               # YOLO êµ¬í˜„
â”‚   â”‚   â”œâ”€â”€ coco_model.py               # COCO í¬ë§· ëª¨ë¸
â”‚   â”‚   â””â”€â”€ schemas.py                  # Pydantic ìŠ¤í‚¤ë§ˆ
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ gt_service.py               # GT ë°ì´í„° ì²˜ë¦¬
â”‚   â”‚   â”œâ”€â”€ register_service.py         # GT ë“±ë¡
â”‚   â”‚   â”œâ”€â”€ inference_service.py        # ì¶”ë¡ 
â”‚   â”‚   â”œâ”€â”€ ensemble_service.py         # ì•™ìƒë¸” (PASS_THREE ë“±)
â”‚   â”‚   â”œâ”€â”€ loop_service.py             # Loop ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ export_service.py           # Export ì²˜ë¦¬
â”‚   â”‚   â””â”€â”€ format_converter.py         # COCO â†” YOLO ë³€í™˜
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ file_handler.py             # íŒŒì¼ ì²˜ë¦¬
â”‚   â”‚   â”œâ”€â”€ json_manager.py             # JSON ì½ê¸°/ì“°ê¸° â­
â”‚   â”‚   â”œâ”€â”€ logger.py                   # ë¡œê¹…
â”‚   â”‚   â””â”€â”€ validators.py               # ë°ì´í„° ê²€ì¦
â”‚   â”‚
â”‚   â””â”€â”€ workers/
â”‚       â””â”€â”€ loop_worker.py              # Loop ì‹¤í–‰ Thread â­
â”‚
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ gt_data/                        # GT ë°ì´í„°
â”‚   â”‚   â”œâ”€â”€ yolo/
â”‚   â”‚   â”‚   â”œâ”€â”€ GT_202601/
â”‚   â”‚   â”‚   â”œâ”€â”€ GT_202602/
â”‚   â”‚   â”‚   â””â”€â”€ GT.file
â”‚   â”‚   â”œâ”€â”€ model2/
â”‚   â”‚   â””â”€â”€ model3/
â”‚   â”‚
â”‚   â”œâ”€â”€ unlabeled/                      # ì¶”ë¡ ìš© ì´ë¯¸ì§€
â”‚   â”‚   â”œâ”€â”€ yolo/
â”‚   â”‚   â”œâ”€â”€ model2/
â”‚   â”‚   â””â”€â”€ model3/
â”‚   â”‚
â”‚   â”œâ”€â”€ results/                        # Loop ê²°ê³¼ â­
â”‚   â”‚   â””â”€â”€ loop_{loop_id}/
â”‚   â”‚       â”œâ”€â”€ run_{run_id}_0/
â”‚   â”‚       â”‚   â”œâ”€â”€ PASS_THREE/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ labels/
â”‚   â”‚       â”‚   â”œâ”€â”€ PASS_TWO/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ labels/
â”‚   â”‚       â”‚   â”œâ”€â”€ FAIL/
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ labels/
â”‚   â”‚       â”‚   â””â”€â”€ MISS/
â”‚   â”‚       â”‚       â””â”€â”€ count.txt
â”‚   â”‚       â”œâ”€â”€ run_{run_id}_1/
â”‚   â”‚       â””â”€â”€ final/
â”‚   â”‚           â”œâ”€â”€ PASS/
â”‚   â”‚           â”œâ”€â”€ FAIL/
â”‚   â”‚           â””â”€â”€ MISS/
â”‚   â”‚
â”‚   â”œâ”€â”€ status/                         # ì§„í–‰ ìƒí™© JSON â­â­â­
â”‚   â”‚   â”œâ”€â”€ loop_{loop_id}.json
â”‚   â”‚   â””â”€â”€ run_{run_id}.json
â”‚   â”‚
â”‚   â””â”€â”€ logs/                           # ë¡œê·¸ íŒŒì¼
â”‚       â”œâ”€â”€ yolo.log
â”‚       â”œâ”€â”€ model2.log
â”‚       â”œâ”€â”€ model3.log
â”‚       â””â”€â”€ system.log
â”‚
â”œâ”€â”€ models/                             # í•™ìŠµëœ ëª¨ë¸ íŒŒì¼
â”‚   â”œâ”€â”€ yolo/
â”‚   â”œâ”€â”€ model2/
â”‚   â””â”€â”€ model3/
â”‚
â”œâ”€â”€ tests/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

### 3.2 í•µì‹¬ JSON êµ¬ì¡°

#### **loop_{loop_id}.json** - Loop ì „ì²´ ìƒíƒœ
```json
{
  "loop_id": "loop_abc123",
  "status": "RUNNING",
  "created_at": "2025-01-05T10:00:00",
  "updated_at": "2025-01-05T11:30:00",
  "completed_at": null,
  
  "config": {
    "total_runs": 4,
    "models": ["yolo", "model2", "model3"],
    "unlabeled_batches": ["batch_001", "batch_002"]
  },
  
  "progress": {
    "current_run": 2,
    "total_runs": 4,
    "percentage": 50.0
  },
  
  "runs": [
    {
      "run_id": "run_xyz789_0",
      "run_number": 0,
      "status": "COMPLETED",
      "started_at": "2025-01-05T10:05:00",
      "completed_at": "2025-01-05T10:45:00",
      "result_path": "/data/results/loop_abc123/run_xyz789_0"
    },
    {
      "run_id": "run_xyz789_1",
      "run_number": 1,
      "status": "COMPLETED",
      "started_at": "2025-01-05T10:46:00",
      "completed_at": "2025-01-05T11:20:00",
      "result_path": "/data/results/loop_abc123/run_xyz789_1"
    },
    {
      "run_id": "run_xyz789_2",
      "run_number": 2,
      "status": "RUNNING",
      "started_at": "2025-01-05T11:21:00",
      "completed_at": null,
      "current_step": "inference_model2",
      "progress": 45.5
    },
    {
      "run_id": "run_xyz789_3",
      "run_number": 3,
      "status": "WAITING",
      "started_at": null,
      "completed_at": null
    }
  ],
  
  "error": null
}
```

#### **run_{run_id}.json** - ê° Run ìƒì„¸ ìƒíƒœ
```json
{
  "run_id": "run_xyz789_2",
  "loop_id": "loop_abc123",
  "run_number": 2,
  "status": "RUNNING",
  "started_at": "2025-01-05T11:21:00",
  "updated_at": "2025-01-05T11:30:00",
  
  "steps": [
    {
      "step": "inference_yolo",
      "status": "COMPLETED",
      "started_at": "2025-01-05T11:21:00",
      "completed_at": "2025-01-05T11:25:00",
      "result": {
        "pass_count": 450,
        "fail_count": 50
      }
    },
    {
      "step": "inference_model2",
      "status": "RUNNING",
      "started_at": "2025-01-05T11:25:00",
      "progress": 65.0,
      "processed_images": 325,
      "total_images": 500
    },
    {
      "step": "inference_model3",
      "status": "WAITING"
    },
    {
      "step": "ensemble",
      "status": "WAITING"
    },
    {
      "step": "export",
      "status": "WAITING"
    }
  ],
  
  "result": {
    "PASS_THREE": 0,
    "PASS_TWO": 0,
    "FAIL": 0,
    "MISS": 0
  }
}
```

---

## 4. í•µì‹¬ API ì„¤ê³„

### 4.1 ë°ì´í„° ì¤€ë¹„ API

#### **1. GT Download** (ëª¨ë¸ë³„ êµ¬í˜„)
```http
POST /api/v1/{model}/gt/download
Content-Type: multipart/form-data

Parameters:
- model: yolo | model2 | model3

Request Body:
- gt_zip: File (ZIP íŒŒì¼)

Response: 200 OK
{
  "success": true,
  "message": "GT ë°ì´í„°ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤",
  "model": "yolo",
  "version_name": "GT_202601",
  "gt_path": "/data/gt_data/yolo/GT_202601",
  "metadata": {
    "images_count": 1500,
    "labels_count": 1500,
    "uploaded_at": "2025-01-05T10:30:00"
  }
}
```

**êµ¬í˜„ ì½”ë“œ:**
```python
# app/api/v1/endpoints/gt_download.py
from fastapi import APIRouter, UploadFile, File, Path, HTTPException
from app.services.gt_service import GTService
from app.core.gt_version_manager import GTVersionManager
from datetime import datetime
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/{model}/gt/download")
async def download_gt(
    model: str = Path(..., regex="^(yolo|model2|model3)$"),
    gt_zip: UploadFile = File(...)
):
    """
    GT ë°ì´í„° ì—…ë¡œë“œ
    
    ì²˜ë¦¬ ê³¼ì •:
    1. ZIP íŒŒì¼ ìˆ˜ì‹ 
    2. ë²„ì „ ì´ë¦„ ìƒì„± (GT_YYYYMM)
    3. ì••ì¶• í•´ì œ
    4. í˜•ì‹ ê²€ì¦
    5. ë²„ì „ ë“±ë¡
    """
    try:
        version_name = f"GT_{datetime.now().strftime('%Y%m')}"
        logger.info(f"GT upload started: model={model}, version={version_name}")
        
        gt_service = GTService(model_type=model)
        
        # ZIP ì—…ë¡œë“œ ë° ì••ì¶• í•´ì œ
        gt_path = await gt_service.upload_and_extract(
            zip_file=gt_zip,
            version_name=version_name
        )
        
        # í˜•ì‹ ê²€ì¦
        validation_result = await gt_service.validate_format(gt_path)
        if not validation_result["valid"]:
            raise HTTPException(
                status_code=400,
                detail=f"GT ë°ì´í„° í˜•ì‹ ì˜¤ë¥˜: {validation_result['errors']}"
            )
        
        # ë²„ì „ ë“±ë¡
        version_manager = GTVersionManager(model_type=model)
        version_info = version_manager.register_version(
            version_name=version_name,
            gt_path=gt_path,
            metadata=validation_result["metadata"]
        )
        
        logger.info(f"GT upload completed: model={model}, version={version_name}")
        
        return {
            "success": True,
            "message": "GT ë°ì´í„°ê°€ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤",
            "model": model,
            "version_name": version_name,
            "gt_path": gt_path,
            "metadata": version_info["metadata"]
        }
        
    except Exception as e:
        logger.error(f"GT upload failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

#### **2. Register** (GT.file ìƒì„±)
```http
POST /api/v1/{model}/register
Content-Type: application/json

Parameters:
- model: yolo | model2 | model3

Request Body:
{
  "version_name": "GT_202601",
  "set_as_active": true
}

Response: 200 OK
{
  "success": true,
  "message": "GT ë°ì´í„°ê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤",
  "model": "yolo",
  "version_name": "GT_202601",
  "gt_file_path": "/data/gt_data/yolo/GT.file",
  "is_active": true
}
```

#### **3. Unlabel Upload**
```http
POST /api/v1/{model}/unlabel/upload
Content-Type: multipart/form-data

Parameters:
- model: yolo | model2 | model3

Request Body:
- images: File[] (ë‹¤ì¤‘ ì´ë¯¸ì§€)
- batch_name: string (ì„ íƒ)

Response: 200 OK
{
  "success": true,
  "model": "yolo",
  "batch_name": "batch_20250105_103000",
  "unlabeled_path": "/data/unlabeled/yolo/batch_20250105_103000",
  "images_count": 500
}
```

---

### 4.2 Loop API

#### **Loop Start**
```http
POST /api/v1/loop/start
Content-Type: application/json

Request Body:
{
  "models": ["yolo", "model2", "model3"],
  "unlabeled_batches": ["batch_001", "batch_002"],
  "total_runs": 4,
  "config": {
    "confidence_threshold": 0.5,
    "iou_threshold": 0.45
  }
}

Response: 200 OK
{
  "success": true,
  "loop_id": "loop_abc123",
  "status": "STARTED",
  "message": "Loopê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤",
  "total_runs": 4,
  "status_file": "/data/status/loop_abc123.json"
}
```

**êµ¬í˜„ ì½”ë“œ:**
```python
# app/api/v1/endpoints/loop.py
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
from typing import List, Dict, Optional
from app.workers.loop_worker import LoopWorker
from app.utils.json_manager import JSONManager
import uuid
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

class LoopConfig(BaseModel):
    confidence_threshold: float = 0.5
    iou_threshold: float = 0.45

class LoopStartRequest(BaseModel):
    models: List[str] = Field(..., min_items=1, max_items=3)
    unlabeled_batches: List[str] = Field(..., min_items=1)
    total_runs: int = Field(..., ge=1, le=100)
    config: Optional[LoopConfig] = LoopConfig()

@router.post("/loop/start")
async def start_loop(request: LoopStartRequest):
    """
    Loop ì‹œì‘
    
    ì²˜ë¦¬ ê³¼ì •:
    1. loop_id ìƒì„±
    2. ì´ˆê¸° JSON íŒŒì¼ ìƒì„±
    3. ë³„ë„ Threadì—ì„œ Loop ì‹¤í–‰
    4. ì¦‰ì‹œ ì‘ë‹µ
    """
    try:
        loop_id = f"loop_{uuid.uuid4().hex[:12]}"
        logger.info(f"Loop start requested: loop_id={loop_id}")
        
        # ì´ˆê¸° JSON íŒŒì¼ ìƒì„±
        json_manager = JSONManager()
        initial_data = {
            "loop_id": loop_id,
            "status": "STARTED",
            "created_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat(),
            "completed_at": None,
            "config": {
                "total_runs": request.total_runs,
                "models": request.models,
                "unlabeled_batches": request.unlabeled_batches,
                "confidence_threshold": request.config.confidence_threshold,
                "iou_threshold": request.config.iou_threshold
            },
            "progress": {
                "current_run": 0,
                "total_runs": request.total_runs,
                "percentage": 0.0
            },
            "runs": [
                {
                    "run_id": None,
                    "run_number": i,
                    "status": "WAITING",
                    "started_at": None,
                    "completed_at": None
                }
                for i in range(request.total_runs)
            ],
            "error": None
        }
        
        json_manager.save_loop_status(loop_id, initial_data)
        logger.info(f"Loop status file created: {loop_id}")
        
        # Loop Worker ì‹œì‘ (ë³„ë„ Thread)
        worker = LoopWorker(
            loop_id=loop_id,
            models=request.models,
            unlabeled_batches=request.unlabeled_batches,
            total_runs=request.total_runs,
            config=request.config.dict()
        )
        worker.start()
        
        logger.info(f"Loop worker started: {loop_id}")
        
        return {
            "success": True,
            "loop_id": loop_id,
            "status": "STARTED",
            "message": "Loopê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤",
            "total_runs": request.total_runs,
            "status_file": f"/data/status/{loop_id}.json"
        }
        
    except Exception as e:
        logger.error(f"Loop start failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

#### **Loop Stop**
```http
POST /api/v1/loop/stop/{loop_id}

Response: 200 OK
{
  "success": true,
  "loop_id": "loop_abc123",
  "message": "Loop ì¤‘ë‹¨ ìš”ì²­ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤"
}
```

---

### 4.3 Event API â­â­â­ (í´ë§ìš©)

#### **ëª©ì **
Spring Bootì—ì„œ 2~3ì´ˆë§ˆë‹¤ ì´ APIë¥¼ í˜¸ì¶œí•˜ì—¬ ì§„í–‰ ìƒí™©ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
```http
GET /api/v1/event/{loop_id}

Response: 200 OK
{
  "loop_id": "loop_abc123",
  "status": "RUNNING",
  "updated_at": "2025-01-05T11:30:00",
  
  "progress": {
    "current_run": 2,
    "total_runs": 4,
    "percentage": 50.0
  },
  
  "current_run_detail": {
    "run_id": "run_xyz789_2",
    "run_number": 2,
    "status": "RUNNING",
    "current_step": "inference_model2",
    "step_progress": 65.0
  },
  
  "runs_summary": [
    {
      "run_number": 0,
      "status": "COMPLETED",
      "completed_at": "2025-01-05T10:45:00"
    },
    {
      "run_number": 1,
      "status": "COMPLETED",
      "completed_at": "2025-01-05T11:20:00"
    },
    {
      "run_number": 2,
      "status": "RUNNING",
      "progress": 45.5
    },
    {
      "run_number": 3,
      "status": "WAITING"
    }
  ]
}
```

**êµ¬í˜„ ì½”ë“œ:**
```python
# app/api/v1/endpoints/event.py
from fastapi import APIRouter, HTTPException, Path
from app.utils.json_manager import JSONManager
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/event/{loop_id}")
async def get_loop_event(loop_id: str = Path(...)):
    """
    Loop ì§„í–‰ ìƒí™© ì¡°íšŒ (í´ë§ìš©)
    
    Spring Bootì—ì„œ 2~3ì´ˆë§ˆë‹¤ ì´ APIë¥¼ í˜¸ì¶œ
    
    ì²˜ë¦¬ ê³¼ì •:
    1. loop_{loop_id}.json íŒŒì¼ ì½ê¸°
    2. í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ run ìƒì„¸ ì •ë³´ í¬í•¨
    3. JSON ë°ì´í„° ê·¸ëŒ€ë¡œ ë°˜í™˜
    """
    try:
        json_manager = JSONManager()
        
        # Loop ìƒíƒœ íŒŒì¼ ì½ê¸°
        loop_status = json_manager.load_loop_status(loop_id)
        
        if not loop_status:
            raise HTTPException(
                status_code=404,
                detail=f"Loop {loop_id}ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
            )
        
        # í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ Run ì°¾ê¸°
        current_run_detail = None
        current_run_number = loop_status["progress"]["current_run"]
        
        for run in loop_status["runs"]:
            if run["run_number"] == current_run_number:
                # ìƒì„¸ Run ì •ë³´ ë¡œë“œ
                if run["run_id"] and run["status"] == "RUNNING":
                    run_detail = json_manager.load_run_status(run["run_id"])
                    if run_detail:
                        current_run_detail = {
                            "run_id": run["run_id"],
                            "run_number": run["run_number"],
                            "status": run["status"],
                            "current_step": run_detail.get("current_step"),
                            "step_progress": run_detail.get("step_progress", 0.0)
                        }
                break
        
        # ì‘ë‹µ êµ¬ì„±
        response = {
            "loop_id": loop_status["loop_id"],
            "status": loop_status["status"],
            "updated_at": loop_status["updated_at"],
            "progress": loop_status["progress"],
            "current_run_detail": current_run_detail,
            "runs_summary": [
                {
                    "run_number": run["run_number"],
                    "status": run["status"],
                    "completed_at": run.get("completed_at")
                }
                for run in loop_status["runs"]
            ]
        }
        
        logger.debug(f"Event polled: loop_id={loop_id}, status={loop_status['status']}")
        
        return response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Event poll failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

---

### 4.4 Export API

#### **Export (ì¤‘ê°„ ì‚°ì¶œë¬¼)**
```http
GET /api/v1/export/{loop_id}/run/{run_number}

Response: 200 OK (ZIP íŒŒì¼)
Content-Type: application/zip
Content-Disposition: attachment; filename="run_0_export.zip"

ZIP ë‚´ìš©:
â”œâ”€â”€ PASS_THREE/
â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â”œâ”€â”€ img_001.jpg
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ labels/
â”‚       â””â”€â”€ coco.json
â”œâ”€â”€ PASS_TWO/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ labels/
â”‚       â”œâ”€â”€ coco.json
â”‚       â””â”€â”€ yolo_*.txt (FAILí•œ ëª¨ë¸ì˜ ê²°ê³¼)
â”œâ”€â”€ FAIL/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ labels/
â”‚       â”œâ”€â”€ coco.json
â”‚       â””â”€â”€ yolo_*.txt
â””â”€â”€ MISS/
    â””â”€â”€ count.txt (ì˜ˆ: "15")
```

**êµ¬í˜„ ì½”ë“œ:**
```python
# app/api/v1/endpoints/export.py
from fastapi import APIRouter, HTTPException, Path
from fastapi.responses import FileResponse
from app.services.export_service import ExportService
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/export/{loop_id}/run/{run_number}")
async def export_run_result(
    loop_id: str = Path(...),
    run_number: int = Path(..., ge=0)
):
    """
    Run ì¤‘ê°„ ì‚°ì¶œë¬¼ ë‹¤ìš´ë¡œë“œ
    
    ë°˜í™˜ êµ¬ì¡°:
    - PASS_THREE: 3ê°œ ëª¨ë¸ ëª¨ë‘ PASS
    - PASS_TWO: 2ê°œ ëª¨ë¸ PASS, 1ê°œ FAIL
    - FAIL: 1ê°œ ì´í•˜ PASS
    - MISS: ê²€ì¶œ ì‹¤íŒ¨
    """
    try:
        logger.info(f"Export requested: loop_id={loop_id}, run={run_number}")
        
        export_service = ExportService()
        
        # ZIP íŒŒì¼ ìƒì„±
        zip_path = export_service.create_run_export(
            loop_id=loop_id,
            run_number=run_number
        )
        
        if not zip_path or not zip_path.exists():
            raise HTTPException(
                status_code=404,
                detail=f"Run {run_number} ê²°ê³¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
            )
        
        logger.info(f"Export completed: {zip_path}")
        
        return FileResponse(
            path=zip_path,
            media_type='application/zip',
            filename=f"run_{run_number}_export.zip"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Export failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

#### **Export Final (ìµœì¢… ì‚°ì¶œë¬¼)**
```http
GET /api/v1/export/{loop_id}/final

Response: 200 OK (ZIP íŒŒì¼)

ZIP ë‚´ìš©:
â”œâ”€â”€ PASS/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ labels/
â”œâ”€â”€ FAIL/
â”‚   â”œâ”€â”€ images/
â”‚   â””â”€â”€ labels/
â””â”€â”€ MISS/
    â””â”€â”€ count.txt
```

---

### 4.5 Log API
```http
GET /api/v1/log/{model}?lines=100

Parameters:
- model: yolo | model2 | model3 | system
- lines: ë°˜í™˜í•  ë¼ì¸ ìˆ˜ (ê¸°ë³¸: 100)

Response: 200 OK
{
  "model": "yolo",
  "log_file": "/data/logs/yolo.log",
  "lines": [
    "[2025-01-05 10:30:00] INFO: Model loaded",
    "[2025-01-05 10:30:15] INFO: Inference started",
    "[2025-01-05 10:35:00] INFO: Inference completed: 500 images",
    ...
  ],
  "total_lines": 100
}
```

**êµ¬í˜„ ì½”ë“œ:**
```python
# app/api/v1/endpoints/log.py
from fastapi import APIRouter, Query, Path, HTTPException
from pathlib import Path as FilePath
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.get("/log/{model}")
async def get_model_log(
    model: str = Path(..., regex="^(yolo|model2|model3|system)$"),
    lines: int = Query(100, ge=1, le=10000)
):
    """
    ëª¨ë¸ ë¡œê·¸ ì¡°íšŒ (ê°œë°œììš©)
    """
    try:
        log_file = FilePath(f"/data/logs/{model}.log")
        
        if not log_file.exists():
            raise HTTPException(
                status_code=404,
                detail=f"ë¡œê·¸ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {model}.log"
            )
        
        # ë§ˆì§€ë§‰ Nì¤„ ì½ê¸°
        with open(log_file, 'r', encoding='utf-8') as f:
            all_lines = f.readlines()
            log_lines = all_lines[-lines:] if len(all_lines) > lines else all_lines
        
        return {
            "model": model,
            "log_file": str(log_file),
            "lines": [line.strip() for line in log_lines],
            "total_lines": len(log_lines)
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Log retrieval failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

---

### 4.6 Switch API (COCO â†” YOLO ë³€í™˜)
```http
POST /api/v1/switch/coco-to-yolo
Content-Type: multipart/form-data

Request Body:
- coco_json: File (COCO JSON íŒŒì¼)
- images_info: JSON (ì´ë¯¸ì§€ í¬ê¸° ì •ë³´, ì„ íƒ)

Response: 200 OK (ZIP íŒŒì¼)
Content-Disposition: attachment; filename="yolo_labels.zip"

ZIP ë‚´ìš©:
â”œâ”€â”€ img_001.txt
â”œâ”€â”€ img_002.txt
â””â”€â”€ ...
```
```http
POST /api/v1/switch/yolo-to-coco
Content-Type: multipart/form-data

Request Body:
- yolo_labels: File[] (YOLO txt íŒŒì¼ë“¤)
- images_info: JSON (ì´ë¯¸ì§€ í¬ê¸° ì •ë³´ í•„ìˆ˜)

Response: 200 OK
{
  "success": true,
  "coco_json_path": "/tmp/coco_output.json",
  "download_url": "/api/v1/switch/download/coco_output.json"
}
```

**êµ¬í˜„ ì½”ë“œ:**
```python
# app/api/v1/endpoints/switch.py
from fastapi import APIRouter, UploadFile, File, HTTPException
from fastapi.responses import FileResponse
from app.services.format_converter import FormatConverter
from typing import List
import logging

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/switch/coco-to-yolo")
async def coco_to_yolo(
    coco_json: UploadFile = File(...),
    images_info: UploadFile = File(None)
):
    """
    COCO JSON â†’ YOLO txt ë³€í™˜
    """
    try:
        logger.info("COCO to YOLO conversion started")
        
        converter = FormatConverter()
        
        # ZIP íŒŒì¼ ìƒì„±
        zip_path = await converter.coco_to_yolo(
            coco_json_file=coco_json,
            images_info_file=images_info
        )
        
        logger.info(f"Conversion completed: {zip_path}")
        
        return FileResponse(
            path=zip_path,
            media_type='application/zip',
            filename="yolo_labels.zip"
        )
        
    except Exception as e:
        logger.error(f"COCO to YOLO failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/switch/yolo-to-coco")
async def yolo_to_coco(
    yolo_labels: List[UploadFile] = File(...),
    images_info: UploadFile = File(...)
):
    """
    YOLO txt â†’ COCO JSON ë³€í™˜
    
    images_info ì˜ˆì‹œ:
    [
      {"file_name": "img_001.jpg", "width": 1920, "height": 1080},
      {"file_name": "img_002.jpg", "width": 1920, "height": 1080}
    ]
    """
    try:
        logger.info("YOLO to COCO conversion started")
        
        converter = FormatConverter()
        
        # COCO JSON ìƒì„±
        coco_json_path = await converter.yolo_to_coco(
            yolo_label_files=yolo_labels,
            images_info_file=images_info
        )
        
        logger.info(f"Conversion completed: {coco_json_path}")
        
        return {
            "success": True,
            "coco_json_path": str(coco_json_path),
            "download_url": f"/api/v1/switch/download/{coco_json_path.name}"
        }
        
    except Exception as e:
        logger.error(f"YOLO to COCO failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))
```

---

## 5. ë°ì´í„° íë¦„

### 5.1 ì•™ìƒë¸” ë¡œì§ (PASS_THREE, PASS_TWO, FAIL, MISS)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          3ê°œ ëª¨ë¸ì˜ ì¶”ë¡  ê²°ê³¼                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                 â”‚
â”‚  ì´ë¯¸ì§€: img_001.jpg                            â”‚
â”‚                                                 â”‚
â”‚  YOLO:    PASS (bbox: [100,100,200,200])       â”‚
â”‚  Model2:  PASS (bbox: [105,102,198,202])       â”‚
â”‚  Model3:  PASS (bbox: [98,99,201,199])         â”‚
â”‚                                                 â”‚
â”‚  â†’ PASS_THREE (3ê°œ ëª¨ë‘ PASS)                  â”‚
â”‚    labels/coco.jsonì— ìµœì¢… bbox ì €ì¥           â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ì´ë¯¸ì§€: img_002.jpg                            â”‚
â”‚                                                 â”‚
â”‚  YOLO:    PASS (bbox: [150,150,250,250])       â”‚
â”‚  Model2:  PASS (bbox: [152,148,248,252])       â”‚
â”‚  Model3:  FAIL (ê²€ì¶œ ì‹¤íŒ¨)                      â”‚
â”‚                                                 â”‚
â”‚  â†’ PASS_TWO (2ê°œ PASS, 1ê°œ FAIL)               â”‚
â”‚    labels/coco.jsonì— PASSí•œ 2ê°œì˜ bbox ì €ì¥   â”‚
â”‚    labels/model3_fail.txtì— FAIL ì •ë³´ ê¸°ë¡     â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ì´ë¯¸ì§€: img_003.jpg                            â”‚
â”‚                                                 â”‚
â”‚  YOLO:    PASS (bbox: [300,300,400,400])       â”‚
â”‚  Model2:  FAIL                                  â”‚
â”‚  Model3:  FAIL                                  â”‚
â”‚                                                 â”‚
â”‚  â†’ FAIL (1ê°œë§Œ PASS)                           â”‚
â”‚    labels/coco.jsonì— PASS 1ê°œ bbox            â”‚
â”‚    labels/model2_fail.txt, model3_fail.txt     â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ì´ë¯¸ì§€: img_004.jpg                            â”‚
â”‚                                                 â”‚
â”‚  YOLO:    FAIL                                  â”‚
â”‚  Model2:  FAIL                                  â”‚
â”‚  Model3:  FAIL                                  â”‚
â”‚                                                 â”‚
â”‚  â†’ MISS (3ê°œ ëª¨ë‘ FAIL, ê²€ì¶œ ì‹¤íŒ¨)             â”‚
â”‚    MISS/count.txtì— ì¹´ìš´íŠ¸ë§Œ ê¸°ë¡              â”‚
â”‚                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì•™ìƒë¸” ì„œë¹„ìŠ¤ êµ¬í˜„:**
```python
# app/services/ensemble_service.py
from pathlib import Path
from typing import Dict, List
import json
import logging

logger = logging.getLogger(__name__)

class EnsembleService:
    """
    3ê°œ ëª¨ë¸ ê²°ê³¼ ì•™ìƒë¸” ë° ë¶„ë¥˜
    - PASS_THREE: 3ê°œ ëª¨ë‘ PASS
    - PASS_TWO: 2ê°œ PASS, 1ê°œ FAIL
    - FAIL: 1ê°œ ì´í•˜ PASS
    - MISS: 3ê°œ ëª¨ë‘ FAIL
    """
    
    def ensemble(
        self,
        predictions_dict: Dict[str, List],
        images_info: List[Dict]
    ) -> Dict:
        """
        ì•™ìƒë¸” ì²˜ë¦¬
        
        Args:
            predictions_dict: {
                "yolo": [predictions],
                "model2": [predictions],
                "model3": [predictions]
            }
            images_info: ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„°
            
        Returns:
            {
                "PASS_THREE": [...],
                "PASS_TWO": [...],
                "FAIL": [...],
                "MISS": [...]
            }
        """
        result = {
            "PASS_THREE": [],
            "PASS_TWO": [],
            "FAIL": [],
            "MISS": []
        }
        
        # ì´ë¯¸ì§€ë³„ë¡œ ì²˜ë¦¬
        for image_info in images_info:
            image_name = image_info["file_name"]
            
            # ê° ëª¨ë¸ì˜ ì˜ˆì¸¡ ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
            yolo_pred = self._get_prediction(predictions_dict["yolo"], image_name)
            model2_pred = self._get_prediction(predictions_dict["model2"], image_name)
            model3_pred = self._get_prediction(predictions_dict["model3"], image_name)
            
            # PASS ê°œìˆ˜ ê³„ì‚°
            pass_count = sum([
                yolo_pred["status"] == "PASS",
                model2_pred["status"] == "PASS",
                model3_pred["status"] == "PASS"
            ])
            
            # ë¶„ë¥˜
            if pass_count == 3:
                # PASS_THREE
                merged_bbox = self._merge_bboxes([
                    yolo_pred["bbox"],
                    model2_pred["bbox"],
                    model3_pred["bbox"]
                ])
                result["PASS_THREE"].append({
                    "image_name": image_name,
                    "bbox": merged_bbox,
                    "confidence": self._average_confidence([
                        yolo_pred["confidence"],
                        model2_pred["confidence"],
                        model3_pred["confidence"]
                    ])
                })
                
            elif pass_count == 2:
                # PASS_TWO
                pass_predictions = []
                fail_model = None
                
                if yolo_pred["status"] == "FAIL":
                    fail_model = "yolo"
                    pass_predictions = [model2_pred, model3_pred]
                elif model2_pred["status"] == "FAIL":
                    fail_model = "model2"
                    pass_predictions = [yolo_pred, model3_pred]
                else:
                    fail_model = "model3"
                    pass_predictions = [yolo_pred, model2_pred]
                
                merged_bbox = self._merge_bboxes([p["bbox"] for p in pass_predictions])
                
                result["PASS_TWO"].append({
                    "image_name": image_name,
                    "bbox": merged_bbox,
                    "confidence": self._average_confidence([p["confidence"] for p in pass_predictions]),
                    "fail_model": fail_model
                })
                
            elif pass_count == 1:
                # FAIL
                pass_prediction = None
                fail_models = []
                
                if yolo_pred["status"] == "PASS":
                    pass_prediction = yolo_pred
                    fail_models = ["model2", "model3"]
                elif model2_pred["status"] == "PASS":
                    pass_prediction = model2_pred
                    fail_models = ["yolo", "model3"]
                else:
                    pass_prediction = model3_pred
                    fail_models = ["yolo", "model2"]
                
                result["FAIL"].append({
                    "image_name": image_name,
                    "bbox": pass_prediction["bbox"],
                    "confidence": pass_prediction["confidence"],
                    "fail_models": fail_models
                })
                
            else:
                # MISS (pass_count == 0)
                result["MISS"].append({
                    "image_name": image_name
                })
        
        logger.info(f"Ensemble completed: PASS_THREE={len(result['PASS_THREE'])}, "
                   f"PASS_TWO={len(result['PASS_TWO'])}, "
                   f"FAIL={len(result['FAIL'])}, "
                   f"MISS={len(result['MISS'])}")
        
        return result
    
    def _get_prediction(self, predictions: List, image_name: str) -> Dict:
        """ì´ë¯¸ì§€ì— ëŒ€í•œ ì˜ˆì¸¡ ê²°ê³¼ ì°¾ê¸°"""
        for pred in predictions:
            if pred["image_name"] == image_name:
                return pred
        
        # ì˜ˆì¸¡ ê²°ê³¼ ì—†ìŒ = FAIL
        return {
            "image_name": image_name,
            "status": "FAIL",
            "bbox": None,
            "confidence": 0.0
        }
    
    def _merge_bboxes(self, bboxes: List) -> List:
        """ì—¬ëŸ¬ bboxë¥¼ í‰ê· ë‚´ì–´ í•˜ë‚˜ë¡œ ë³‘í•©"""
        if not bboxes or any(b is None for b in bboxes):
            return None
        
        # [x1, y1, x2, y2] í˜•ì‹
        x1 = sum(b[0] for b in bboxes) / len(bboxes)
        y1 = sum(b[1] for b in bboxes) / len(bboxes)
        x2 = sum(b[2] for b in bboxes) / len(bboxes)
        y2 = sum(b[3] for b in bboxes) / len(bboxes)
        
        return [x1, y1, x2, y2]
    
    def _average_confidence(self, confidences: List[float]) -> float:
        """Confidence í‰ê· """
        return sum(confidences) / len(confidences)
    
    def save_results(
        self,
        result: Dict,
        output_base_path: Path
    ):
        """
        ì•™ìƒë¸” ê²°ê³¼ ì €ì¥
        
        êµ¬ì¡°:
        output_base_path/
        â”œâ”€â”€ PASS_THREE/
        â”‚   â”œâ”€â”€ images/
        â”‚   â””â”€â”€ labels/
        â”‚       â””â”€â”€ coco.json
        â”œâ”€â”€ PASS_TWO/
        â”‚   â”œâ”€â”€ images/
        â”‚   â””â”€â”€ labels/
        â”‚       â”œâ”€â”€ coco.json
        â”‚       â””â”€â”€ {fail_model}_fail.txt
        â”œâ”€â”€ FAIL/
        â”‚   â”œâ”€â”€ images/
        â”‚   â””â”€â”€ labels/
        â”‚       â”œâ”€â”€ coco.json
        â”‚       â””â”€â”€ {fail_model}_fail.txt
        â””â”€â”€ MISS/
            â””â”€â”€ count.txt
        """
        # PASS_THREE ì €ì¥
        self._save_category(
            result["PASS_THREE"],
            output_base_path / "PASS_THREE",
            include_fail_info=False
        )
        
        # PASS_TWO ì €ì¥
        self._save_category(
            result["PASS_TWO"],
            output_base_path / "PASS_TWO",
            include_fail_info=True
        )
        
        # FAIL ì €ì¥
        self._save_category(
            result["FAIL"],
            output_base_path / "FAIL",
            include_fail_info=True
        )
        
        # MISS ì €ì¥
        miss_path = output_base_path / "MISS"
        miss_path.mkdir(parents=True, exist_ok=True)
        count_file = miss_path / "count.txt"
        count_file.write_text(str(len(result["MISS"])))
        
        logger.info(f"Results saved to {output_base_path}")
    
    def _save_category(
        self,
        items: List[Dict],
        category_path: Path,
        include_fail_info: bool
    ):
        """ì¹´í…Œê³ ë¦¬ë³„ ì €ì¥"""
        images_path = category_path / "images"
        labels_path = category_path / "labels"
        images_path.mkdir(parents=True, exist_ok=True)
        labels_path.mkdir(parents=True, exist_ok=True)
        
        # COCO JSON ìƒì„±
        coco_data = {
            "images": [],
            "annotations": [],
            "categories": [{"id": 1, "name": "object"}]
        }
        
        annotation_id = 1
        for idx, item in enumerate(items):
            image_id = idx + 1
            
            # ì´ë¯¸ì§€ ì •ë³´
            coco_data["images"].append({
                "id": image_id,
                "file_name": item["image_name"],
                "width": 1920,  # ì‹¤ì œ ì´ë¯¸ì§€ í¬ê¸° ì‚¬ìš©
                "height": 1080
            })
            
            # Annotation
            if item.get("bbox"):
                x1, y1, x2, y2 = item["bbox"]
                coco_data["annotations"].append({
                    "id": annotation_id,
                    "image_id": image_id,
                    "category_id": 1,
                    "bbox": [x1, y1, x2 - x1, y2 - y1],  # COCO: [x, y, w, h]
                    "area": (x2 - x1) * (y2 - y1),
                    "iscrowd": 0
                })
                annotation_id += 1
            
            # ì´ë¯¸ì§€ ë³µì‚¬ (ì‹¤ì œ êµ¬í˜„ ì‹œ)
            # shutil.copy(source_image, images_path / item["image_name"])
        
        # COCO JSON ì €ì¥
        coco_json_path = labels_path / "coco.json"
        with open(coco_json_path, 'w') as f:
            json.dump(coco_data, f, indent=2)
        
        # FAIL ì •ë³´ ì €ì¥ (PASS_TWO, FAIL ì¹´í…Œê³ ë¦¬)
        if include_fail_info:
            fail_info = {}
            for item in items:
                if "fail_model" in item:
                    fail_model = item["fail_model"]
                    if fail_model not in fail_info:
                        fail_info[fail_model] = []
                    fail_info[fail_model].append(item["image_name"])
                elif "fail_models" in item:
                    for fail_model in item["fail_models"]:
                        if fail_model not in fail_info:
                            fail_info[fail_model] = []
                        fail_info[fail_model].append(item["image_name"])
            
            # ê° FAIL ëª¨ë¸ë³„ë¡œ txt íŒŒì¼ ìƒì„±
            for fail_model, image_names in fail_info.items():
                fail_file = labels_path / f"{fail_model}_fail.txt"
                fail_file.write_text("\n".join(image_names))
```

---

### 5.2 JSON íŒŒì¼ ê´€ë¦¬
```python
# app/utils/json_manager.py
from pathlib import Path
from typing import Dict, Optional
import json
import fcntl  # íŒŒì¼ ë½
import logging

logger = logging.getLogger(__name__)

class JSONManager:
    """
    JSON íŒŒì¼ ì½ê¸°/ì“°ê¸° ê´€ë¦¬
    - íŒŒì¼ ë½ìœ¼ë¡œ ë™ì‹œì„± ì œì–´
    - ì›ìì  ì“°ê¸° (atomic write)
    """
    
    def __init__(self):
        self.status_dir = Path("/data/status")
        self.status_dir.mkdir(parents=True, exist_ok=True)
    
    def save_loop_status(self, loop_id: str, data: Dict):
        """
        Loop ìƒíƒœ ì €ì¥
        
        íŒŒì¼ ë½ì„ ì‚¬ìš©í•˜ì—¬ ë™ì‹œ ì“°ê¸° ë°©ì§€
        """
        file_path = self.status_dir / f"{loop_id}.json"
        temp_path = self.status_dir / f"{loop_id}.json.tmp"
        
        try:
            # ì„ì‹œ íŒŒì¼ì— ì“°ê¸°
            with open(temp_path, 'w', encoding='utf-8') as f:
                # íŒŒì¼ ë½ (ë°°íƒ€ì )
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                json.dump(data, f, indent=2, ensure_ascii=False)
                fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            
            # ì›ìì  ì´ë™ (atomic rename)
            temp_path.rename(file_path)
            
            logger.debug(f"Loop status saved: {loop_id}")
            
        except Exception as e:
            logger.error(f"Failed to save loop status: {str(e)}")
            if temp_path.exists():
                temp_path.unlink()
            raise
    
    def load_loop_status(self, loop_id: str) -> Optional[Dict]:
        """Loop ìƒíƒœ ì½ê¸°"""
        file_path = self.status_dir / f"{loop_id}.json"
        
        if not file_path.exists():
            return None
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                # íŒŒì¼ ë½ (ê³µìœ )
                fcntl.flock(f.fileno(), fcntl.LOCK_SH)
                data = json.load(f)
                fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            
            return data
            
        except Exception as e:
            logger.error(f"Failed to load loop status: {str(e)}")
            return None
    
    def save_run_status(self, run_id: str, data: Dict):
        """Run ìƒíƒœ ì €ì¥"""
        file_path = self.status_dir / f"{run_id}.json"
        temp_path = self.status_dir / f"{run_id}.json.tmp"
        
        try:
            with open(temp_path, 'w', encoding='utf-8') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                json.dump(data, f, indent=2, ensure_ascii=False)
                fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            
            temp_path.rename(file_path)
            logger.debug(f"Run status saved: {run_id}")
            
        except Exception as e:
            logger.error(f"Failed to save run status: {str(e)}")
            if temp_path.exists():
                temp_path.unlink()
            raise
    
    def load_run_status(self, run_id: str) -> Optional[Dict]:
        """Run ìƒíƒœ ì½ê¸°"""
        file_path = self.status_dir / f"{run_id}.json"
        
        if not file_path.exists():
            return None
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH)
                data = json.load(f)
                fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            
            return data
            
        except Exception as e:
            logger.error(f"Failed to load run status: {str(e)}")
            return None
    
    def update_loop_progress(
        self,
        loop_id: str,
        current_run: int,
        percentage: float
    ):
        """Loop ì§„í–‰ë¥  ì—…ë°ì´íŠ¸"""
        data = self.load_loop_status(loop_id)
        if data:
            data["progress"]["current_run"] = current_run
            data["progress"]["percentage"] = percentage
            data["updated_at"] = datetime.now().isoformat()
            self.save_loop_status(loop_id, data)
    
    def update_run_step(
        self,
        run_id: str,
        step: str,
        status: str,
        progress: float = None
    ):
        """Run ë‹¨ê³„ ì—…ë°ì´íŠ¸"""
        data = self.load_run_status(run_id)
        if data:
            data["current_step"] = step
            data["step_progress"] = progress or 0.0
            data["updated_at"] = datetime.now().isoformat()
            
            # steps ë°°ì—´ ì—…ë°ì´íŠ¸
            for step_info in data.get("steps", []):
                if step_info["step"] == step:
                    step_info["status"] = status
                    if progress is not None:
                        step_info["progress"] = progress
                    if status == "COMPLETED":
                        step_info["completed_at"] = datetime.now().isoformat()
                    break
            
            self.save_run_status(run_id, data)
```

---

### 5.3 Loop Worker (Thread ê¸°ë°˜)
```python
# app/workers/loop_worker.py
from threading import Thread
from pathlib import Path
from typing import List, Dict
from datetime import datetime
from app.utils.json_manager import JSONManager
from app.services.inference_service import InferenceService
from app.services.ensemble_service import EnsembleService
import uuid
import logging

logger = logging.getLogger(__name__)

class LoopWorker(Thread):
    """
    Loop ì‹¤í–‰ Worker (ë³„ë„ Thread)
    
    ì—­í• :
    1. Loop ì „ì²´ ì‹¤í–‰
    2. Runë³„ ì²˜ë¦¬ (ì¶”ë¡  â†’ ì•™ìƒë¸” â†’ ì €ì¥)
    3. JSON íŒŒì¼ ì—…ë°ì´íŠ¸
    """
    
    def __init__(
        self,
        loop_id: str,
        models: List[str],
        unlabeled_batches: List[str],
        total_runs: int,
        config: Dict
    ):
        super().__init__(daemon=True)
        
        self.loop_id = loop_id
        self.models = models
        self.unlabeled_batches = unlabeled_batches
        self.total_runs = total_runs
        self.config = config
        
        self.json_manager = JSONManager()
        self.should_stop = False
    
    def run(self):
        """Thread ì‹¤í–‰"""
        try:
            logger.info(f"Loop worker started: {self.loop_id}")
            
            # ê²°ê³¼ ê²½ë¡œ
            results_base = Path(f"/data/results/{self.loop_id}")
            results_base.mkdir(parents=True, exist_ok=True)
            
            # ì¶”ë¡  ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
            inference_services = {
                model: InferenceService(model_type=model)
                for model in self.models
            }
            
            # ì•™ìƒë¸” ì„œë¹„ìŠ¤
            ensemble_service = EnsembleService()
            
            # Run ë°˜ë³µ
            for run_number in range(self.total_runs):
                if self.should_stop:
                    logger.info(f"Loop stopped by user: {self.loop_id}")
                    break
                
                logger.info(f"=== Run {run_number} started ===")
                
                # Run ID ìƒì„±
                run_id = f"run_{uuid.uuid4().hex[:12]}_{run_number}"
                
                # Run ì´ˆê¸° JSON ìƒì„±
                self._initialize_run_json(run_id, run_number)
                
                # Run ê²½ë¡œ
                run_path = results_base / f"{run_id}"
                run_path.mkdir(parents=True, exist_ok=True)
                
                try:
                    # Step 1: ê° ëª¨ë¸ë¡œ ì¶”ë¡ 
                    all_predictions = {}
                    for model_name, service in inference_services.items():
                        logger.info(f"Run {run_number} - {model_name} inference")
                        
                        # JSON ì—…ë°ì´íŠ¸
                        self.json_manager.update_run_step(
                            run_id=run_id,
                            step=f"inference_{model_name}",
                            status="RUNNING"
                        )
                        
                        # ì¶”ë¡  ì‹¤í–‰
                        predictions = service.infer_batch(
                            images_paths=self.unlabeled_batches,
                            callback=lambda p: self.json_manager.update_run_step(
                                run_id=run_id,
                                step=f"inference_{model_name}",
                                status="RUNNING",
                                progress=p
                            )
                        )
                        all_predictions[model_name] = predictions
                        
                        # ì™„ë£Œ
                        self.json_manager.update_run_step(
                            run_id=run_id,
                            step=f"inference_{model_name}",
                            status="COMPLETED"
                        )
                        
                        logger.info(f"Run {run_number} - {model_name} completed")
                    
                    # Step 2: ì•™ìƒë¸”
                    logger.info(f"Run {run_number} - Ensemble")
                    self.json_manager.update_run_step(
                        run_id=run_id,
                        step="ensemble",
                        status="RUNNING"
                    )
                    
                    images_info = self._get_images_info()
                    ensemble_result = ensemble_service.ensemble(
                        predictions_dict=all_predictions,
                        images_info=images_info
                    )
                    
                    self.json_manager.update_run_step(
                        run_id=run_id,
                        step="ensemble",
                        status="COMPLETED"
                    )
                    
                    # Step 3: ê²°ê³¼ ì €ì¥
                    logger.info(f"Run {run_number} - Saving results")
                    self.json_manager.update_run_step(
                        run_id=run_id,
                        step="export",
                        status="RUNNING"
                    )
                    
                    ensemble_service.save_results(
                        result=ensemble_result,
                        output_base_path=run_path
                    )
                    
                    self.json_manager.update_run_step(
                        run_id=run_id,
                        step="export",
                        status="COMPLETED"
                    )
                    
                    # Run ì™„ë£Œ
                    self._complete_run(run_id, run_number, str(run_path))
                    
                    logger.info(f"=== Run {run_number} completed ===")
                    
                except Exception as e:
                    logger.error(f"Run {run_number} failed: {str(e)}")
                    self._fail_run(run_id, run_number, str(e))
                    # ì‹¤íŒ¨í•´ë„ ë‹¤ìŒ Run ê³„ì† ì§„í–‰
                
                # Loop ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                percentage = ((run_number + 1) / self.total_runs) * 100
                self.json_manager.update_loop_progress(
                    loop_id=self.loop_id,
                    current_run=run_number + 1,
                    percentage=percentage
                )
            
            # Loop ì „ì²´ ì™„ë£Œ
            self._complete_loop()
            
            logger.info(f"Loop worker completed: {self.loop_id}")
            
        except Exception as e:
            logger.error(f"Loop worker failed: {str(e)}")
            self._fail_loop(str(e))
    
    def stop(self):
        """Loop ì¤‘ë‹¨"""
        self.should_stop = True
    
    def _initialize_run_json(self, run_id: str, run_number: int):
        """Run ì´ˆê¸° JSON ìƒì„±"""
        run_data = {
            "run_id": run_id,
            "loop_id": self.loop_id,
            "run_number": run_number,
            "status": "RUNNING",
            "started_at": datetime.now().isoformat(),
            "updated_at": datetime.now().isoformat(),
            "current_step": None,
            "step_progress": 0.0,
            "steps": [
                {"step": f"inference_{model}", "status": "WAITING"}
                for model in self.models
            ] + [
                {"step": "ensemble", "status": "WAITING"},
                {"step": "export", "status": "WAITING"}
            ],
            "result": {
                "PASS_THREE": 0,
                "PASS_TWO": 0,
                "FAIL": 0,
                "MISS": 0
            }
        }
        
        self.json_manager.save_run_status(run_id, run_data)
        
        # Loop JSONì—ë„ ë°˜ì˜
        loop_data = self.json_manager.load_loop_status(self.loop_id)
        if loop_data:
            for run in loop_data["runs"]:
                if run["run_number"] == run_number:
                    run["run_id"] = run_id
                    run["status"] = "RUNNING"
                    run["started_at"] = datetime.now().isoformat()
                    break
            self.json_manager.save_loop_status(self.loop_id, loop_data)
    
    def _complete_run(self, run_id: str, run_number: int, result_path: str):
        """Run ì™„ë£Œ ì²˜ë¦¬"""
        # Run JSON ì—…ë°ì´íŠ¸
        run_data = self.json_manager.load_run_status(run_id)
        if run_data:
            run_data["status"] = "COMPLETED"
            run_data["completed_at"] = datetime.now().isoformat()
            self.json_manager.save_run_status(run_id, run_data)
        
        # Loop JSON ì—…ë°ì´íŠ¸
        loop_data = self.json_manager.load_loop_status(self.loop_id)
        if loop_data:
            for run in loop_data["runs"]:
                if run["run_number"] == run_number:
                    run["status"] = "COMPLETED"
                    run["completed_at"] = datetime.now().isoformat()
                    run["result_path"] = result_path
                    break
            self.json_manager.save_loop_status(self.loop_id, loop_data)
    
    def _fail_run(self, run_id: str, run_number: int, error: str):
        """Run ì‹¤íŒ¨ ì²˜ë¦¬"""
        # Run JSON ì—…ë°ì´íŠ¸
        run_data = self.json_manager.load_run_status(run_id)
        if run_data:
            run_data["status"] = "FAILED"
            run_data["error"] = error
            run_data["failed_at"] = datetime.now().isoformat()
            self.json_manager.save_run_status(run_id, run_data)
        
        # Loop JSON ì—…ë°ì´íŠ¸
        loop_data = self.json_manager.load_loop_status(self.loop_id)
        if loop_data:
            for run in loop_data["runs"]:
                if run["run_number"] == run_number:
                    run["status"] = "FAILED"
                    run["error"] = error
                    break
            self.json_manager.save_loop_status(self.loop_id, loop_data)
    
    def _complete_loop(self):
        """Loop ì „ì²´ ì™„ë£Œ"""
        loop_data = self.json_manager.load_loop_status(self.loop_id)
        if loop_data:
            loop_data["status"] = "COMPLETED"
            loop_data["completed_at"] = datetime.now().isoformat()
            self.json_manager.save_loop_status(self.loop_id, loop_data)
    
    def _fail_loop(self, error: str):
        """Loop ì „ì²´ ì‹¤íŒ¨"""
        loop_data = self.json_manager.load_loop_status(self.loop_id)
        if loop_data:
            loop_data["status"] = "FAILED"
            loop_data["error"] = error
            loop_data["failed_at"] = datetime.now().isoformat()
            self.json_manager.save_loop_status(self.loop_id, loop_data)
    
    def _get_images_info(self) -> List[Dict]:
        """ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° ìˆ˜ì§‘"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” unlabeled_batchesì—ì„œ ì´ë¯¸ì§€ ì •ë³´ ìˆ˜ì§‘
        return []
```

---

## 6. êµ¬í˜„ ì½”ë“œ

### 6.1 Format Converter (COCO â†” YOLO)
```python
# app/services/format_converter.py
from pathlib import Path
from typing import List
from fastapi import UploadFile
import json
import zipfile
import tempfile
import logging

logger = logging.getLogger(__name__)

class FormatConverter:
    """
    COCO â†” YOLO í¬ë§· ë³€í™˜
    """
    
    async def coco_to_yolo(
        self,
        coco_json_file: UploadFile,
        images_info_file: UploadFile = None
    ) -> Path:
        """
        COCO JSON â†’ YOLO txt ë³€í™˜
        
        Returns:
            ZIP íŒŒì¼ ê²½ë¡œ
        """
        try:
            # COCO JSON ë¡œë“œ
            coco_data = json.loads(await coco_json_file.read())
            
            # ì´ë¯¸ì§€ ID â†’ í¬ê¸° ë§¤í•‘
            image_sizes = {}
            for img in coco_data["images"]:
                image_sizes[img["id"]] = {
                    "width": img["width"],
                    "height": img["height"],
                    "file_name": img["file_name"]
                }
            
            # ì¹´í…Œê³ ë¦¬ ID â†’ í´ë˜ìŠ¤ ì¸ë±ìŠ¤ ë§¤í•‘
            category_map = {}
            for idx, cat in enumerate(coco_data["categories"]):
                category_map[cat["id"]] = idx
            
            # ì„ì‹œ ë””ë ‰í† ë¦¬
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)
                
                # Annotationë³„ë¡œ YOLO íŒŒì¼ ìƒì„±
                yolo_annotations = {}
                for ann in coco_data["annotations"]:
                    image_id = ann["image_id"]
                    
                    if image_id not in yolo_annotations:
                        yolo_annotations[image_id] = []
                    
                    # COCO bbox: [x, y, width, height]
                    # YOLO bbox: [x_center, y_center, width, height] (ì •ê·œí™”)
                    img_info = image_sizes[image_id]
                    img_w = img_info["width"]
                    img_h = img_info["height"]
                    
                    x, y, w, h = ann["bbox"]
                    x_center = (x + w / 2) / img_w
                    y_center = (y + h / 2) / img_h
                    width = w / img_w
                    height = h / img_h
                    
                    class_idx = category_map[ann["category_id"]]
                    
                    yolo_line = f"{class_idx} {x_center:.6f} {y_center:.6f} {width:.6f} {height:.6f}"
                    yolo_annotations[image_id].append(yolo_line)
                
                # YOLO txt íŒŒì¼ ìƒì„±
                for image_id, lines in yolo_annotations.items():
                    img_info = image_sizes[image_id]
                    file_name = Path(img_info["file_name"]).stem + ".txt"
                    
                    txt_file = temp_path / file_name
                    txt_file.write_text("\n".join(lines))
                
                # ZIP íŒŒì¼ ìƒì„±
                zip_path = Path(tempfile.mktemp(suffix=".zip"))
                with zipfile.ZipFile(zip_path, 'w') as zf:
                    for txt_file in temp_path.glob("*.txt"):
                        zf.write(txt_file, txt_file.name)
                
                logger.info(f"COCO to YOLO conversion completed: {zip_path}")
                return zip_path
                
        except Exception as e:
            logger.error(f"COCO to YOLO failed: {str(e)}")
            raise
    
    async def yolo_to_coco(
        self,
        yolo_label_files: List[UploadFile],
        images_info_file: UploadFile
    ) -> Path:
        """
        YOLO txt â†’ COCO JSON ë³€í™˜
        
        Args:
            yolo_label_files: YOLO txt íŒŒì¼ë“¤
            images_info_file: ì´ë¯¸ì§€ ì •ë³´ JSON
                [
                  {"file_name": "img.jpg", "width": 1920, "height": 1080},
                  ...
                ]
        
        Returns:
            COCO JSON íŒŒì¼ ê²½ë¡œ
        """
        try:
            # ì´ë¯¸ì§€ ì •ë³´ ë¡œë“œ
            images_info = json.loads(await images_info_file.read())
            
            # ì´ë¯¸ì§€ ì´ë¦„ â†’ ì •ë³´ ë§¤í•‘
            image_map = {
                Path(info["file_name"]).stem: info
                for info in images_info
            }
            
            # COCO ë°ì´í„° ì´ˆê¸°í™”
            coco_data = {
                "images": [],
                "annotations": [],
                "categories": [{"id": 1, "name": "object"}]
            }
            
            annotation_id = 1
            
            # YOLO íŒŒì¼ë“¤ ì²˜ë¦¬
            for idx, yolo_file in enumerate(yolo_label_files):
                image_id = idx + 1
                
                # íŒŒì¼ ì´ë¦„ì—ì„œ ì´ë¯¸ì§€ ì´ë¦„ ì¶”ì¶œ
                stem = Path(yolo_file.filename).stem
                
                if stem not in image_map:
                    logger.warning(f"Image info not found: {stem}")
                    continue
                
                img_info = image_map[stem]
                img_w = img_info["width"]
                img_h = img_info["height"]
                
                # COCO images ì¶”ê°€
                coco_data["images"].append({
                    "id": image_id,
                    "file_name": img_info["file_name"],
                    "width": img_w,
                    "height": img_h
                })
                
                # YOLO ë¼ë²¨ ì½ê¸°
                content = (await yolo_file.read()).decode('utf-8')
                lines = content.strip().split('\n')
                
                for line in lines:
                    if not line.strip():
                        continue
                    
                    parts = line.strip().split()
                    if len(parts) != 5:
                        continue
                    
                    class_idx, x_center, y_center, width, height = map(float, parts)
                    
                    # YOLO â†’ COCO ë³€í™˜
                    # YOLO: [x_center, y_center, width, height] (ì •ê·œí™”)
                    # COCO: [x, y, width, height] (í”½ì…€)
                    x_center_px = x_center * img_w
                    y_center_px = y_center * img_h
                    width_px = width * img_w
                    height_px = height * img_h
                    
                    x = x_center_px - width_px / 2
                    y = y_center_px - height_px / 2
                    
                    coco_data["annotations"].append({
                        "id": annotation_id,
                        "image_id": image_id,
                        "category_id": int(class_idx) + 1,
                        "bbox": [x, y, width_px, height_px],
                        "area": width_px * height_px,
                        "iscrowd": 0
                    })
                    annotation_id += 1
            
            # COCO JSON ì €ì¥
            output_path = Path(tempfile.mktemp(suffix="_coco.json"))
            with open(output_path, 'w') as f:
                json.dump(coco_data, f, indent=2)
            
            logger.info(f"YOLO to COCO conversion completed: {output_path}")
            return output_path
            
        except Exception as e:
            logger.error(f"YOLO to COCO failed: {str(e)}")
            raise
```

---

## 7. ì„¤ì¹˜ ë° ì‹¤í–‰

### 7.1 Docker Compose (ë‹¨ìˆœí™”)
```yaml
# docker-compose.yml
version: '3.8'

services:
  fastapi:
    build: .
    container_name: fastapi_ai
    ports:
      - "8000:8000"
    volumes:
      - ./app:/app
      - ./data:/data
      - ./models:/models
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
```

### 7.2 ì‹¤í–‰
```bash
# Docker Compose ì‹¤í–‰
docker-compose up -d --build

# ë¡œê·¸ í™•ì¸
docker-compose logs -f fastapi

# ìƒíƒœ í™•ì¸
curl http://localhost:8000/health

# API ë¬¸ì„œ
open http://localhost:8000/docs
```

---

## 8. íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### 8.1 JSON íŒŒì¼ ë™ì‹œ ì ‘ê·¼ ë¬¸ì œ

**ë¬¸ì œ**: ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì‹œì— JSON íŒŒì¼ ì½ê¸°/ì“°ê¸°

**í•´ê²°**: fcntl íŒŒì¼ ë½ ì‚¬ìš© (ì´ë¯¸ êµ¬í˜„ë¨)

### 8.2 í´ë§ ë¶€í•˜

**ë¬¸ì œ**: Spring Bootê°€ 2ì´ˆë§ˆë‹¤ í´ë§ â†’ ì„œë²„ ë¶€í•˜

**í•´ê²°**: 
- JSON íŒŒì¼ ì½ê¸°ëŠ” ë¹ ë¦„ (ë””ìŠ¤í¬ ìºì‹œ)
- status ë³€ê²½ ì‹œì—ë§Œ ì‹¤ì œ ë””ìŠ¤í¬ I/O
- í•„ìš”ì‹œ í´ë§ ì£¼ê¸° ì¡°ì • (3~5ì´ˆ)

### 8.3 Loop Thread ë©”ëª¨ë¦¬ ëˆ„ìˆ˜

**ë¬¸ì œ**: Loopê°€ ê¸¸ì–´ì§€ë©´ ë©”ëª¨ë¦¬ ì¦ê°€

**í•´ê²°**:
```python
# Loop Workerì—ì„œ ëª…ì‹œì  ë©”ëª¨ë¦¬ ì •ë¦¬
import gc

def run(self):
    try:
        # Loop ì‹¤í–‰
        ...
    finally:
        # ë©”ëª¨ë¦¬ ì •ë¦¬
        gc.collect()
```

---

## 9. Spring Boot ì—°ë™ ì˜ˆì‹œ
```java
@Service
public class FastAPIService {
    
    private final WebClient webClient;
    private final ScheduledExecutorService scheduler;
    
    public FastAPIService() {
        this.webClient = WebClient.builder()
            .baseUrl("http://fastapi:8000/api/v1")
            .build();
        
        this.scheduler = Executors.newScheduledThreadPool(1);
    }
    
    /**
     * Loop ì‹œì‘ ë° í´ë§ ì‹œì‘
     */
    public Mono<String> startLoopWithPolling(LoopRequest request) {
        return webClient.post()
            .uri("/loop/start")
            .bodyValue(request)
            .retrieve()
            .bodyToMono(LoopResponse.class)
            .map(response -> {
                String loopId = response.getLoopId();
                
                // í´ë§ ì‹œì‘ (2ì´ˆë§ˆë‹¤)
                scheduler.scheduleAtFixedRate(
                    () -> pollLoopProgress(loopId),
                    0, 2, TimeUnit.SECONDS
                );
                
                return loopId;
            });
    }
    
    /**
     * Loop ì§„í–‰ ìƒí™© í´ë§
     */
    private void pollLoopProgress(String loopId) {
        webClient.get()
            .uri("/event/{loopId}", loopId)
            .retrieve()
            .bodyToMono(LoopEventResponse.class)
            .subscribe(
                progress -> {
                    log.info("Loop progress: {}/{}", 
                        progress.getProgress().getCurrentRun(),
                        progress.getProgress().getTotalRuns());
                    
                    // Reactë¡œ SSE ì „ì†¡ ë˜ëŠ” DB ì €ì¥
                    sendProgressToFrontend(progress);
                    
                    // ì™„ë£Œ ì‹œ í´ë§ ì¤‘ë‹¨
                    if ("COMPLETED".equals(progress.getStatus()) ||
                        "FAILED".equals(progress.getStatus())) {
                        scheduler.shutdown();
                    }
                },
                error -> log.error("Polling failed", error)
            );
    }
}
```

---

## ê²°ë¡ 

ì´ ì„¤ê³„ëŠ” **Redis, WebSocket, SSE ì—†ì´** JSON íŒŒì¼ ê¸°ë°˜ + REST API í´ë§ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ **ì™¸ë¶€ ì˜ì¡´ì„±ì„ ìµœì†Œí™”**í–ˆìŠµë‹ˆë‹¤.

### í•µì‹¬ íŠ¹ì§•
âœ… JSON íŒŒì¼ë¡œ ìƒíƒœ ê´€ë¦¬ (íŒŒì¼ ë½ìœ¼ë¡œ ë™ì‹œì„± ì œì–´)
âœ… REST API í´ë§ (Spring Bootì—ì„œ 2~3ì´ˆë§ˆë‹¤ event API í˜¸ì¶œ)
âœ… Thread ê¸°ë°˜ ë¹„ë™ê¸° Loop ì‹¤í–‰
âœ… PASS_THREE, PASS_TWO, FAIL, MISS ë¶„ë¥˜
âœ… COCO â†” YOLO í¬ë§· ë³€í™˜ ì§€ì›
âœ… ëª¨ë¸ë³„ ë…ë¦½ì ì¸ API êµ¬ì¡°

í•„ìš”í•˜ì‹  ë¶€ë¶„ì´ ìˆìœ¼ë©´ ì–¸ì œë“ ì§€ ë§ì”€í•´ì£¼ì„¸ìš”! ğŸ˜Š